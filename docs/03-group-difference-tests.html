<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.24">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>3&nbsp; 제3장 집단 간 평균 차이 검증 – 사회과학 연구자를 위한 파이썬 기반 통계 분석</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./04-categorical-data-analysis.html" rel="next">
<link href="./02-data-handling-exploration.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-a37c72dd2dbac68997fcdc15a3622e78.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-39838fb7f56cda2388fb8ff725d4938e.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./03-group-difference-tests.html">제2부 - 집단 간 차이 분석 및 관계 분석</a></li><li class="breadcrumb-item"><a href="./03-group-difference-tests.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">제3장 집단 간 평균 차이 검증</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">사회과학 연구자를 위한 파이썬 기반 통계 분석</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">맞이하는 글</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">목차</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">제1부 - 파이썬을 활용한 사회과학 데이터 분석 준비</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./01-research-data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">제1장: 사회과학 연구와 데이터의 이해</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./02-data-handling-exploration.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">제 2장 파이썬을 이용한 데이터 핸들링 및 탐색</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">제2부 - 집단 간 차이 분석 및 관계 분석</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./03-group-difference-tests.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">제3장 집단 간 평균 차이 검증</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./04-categorical-data-analysis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">04-categorical-data-analysis.html</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./05-correlation-analysis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">05-correlation-analysis.html</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">제3부 - 예측 및 설명 모델링</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./06-linear-regression.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">06-linear-regression.html</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./07-logistic-regression.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">07-logistic-regression.html</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./08-decision-tree.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">8</span>&nbsp; <span class="chapter-title">08-decision-tree.html</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./09-cluster-analysis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">9</span>&nbsp; <span class="chapter-title">09-cluster-analysis.html</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./10-factor-analysis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">10</span>&nbsp; <span class="chapter-title">10-factor-analysis.html</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true">
 <span class="menu-text">제4부 - 심화 분석 기법 (선택적)</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./11-structural-equation-modeling.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">11</span>&nbsp; <span class="chapter-title">11-structural-equation-modeling.html</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./12-multidimensional-scaling.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">12</span>&nbsp; <span class="chapter-title">12-multidimensional-scaling.html</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./13-correspondence-analysis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">13</span>&nbsp; <span class="chapter-title">13-correspondence-analysis.html</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./14-conjoint-analysis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">14</span>&nbsp; <span class="chapter-title">14-conjoint-analysis.html</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./15-time-series-analysis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">15</span>&nbsp; <span class="chapter-title">15-time-series-analysis.html</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./3a_sub.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">A</span>&nbsp; <span class="chapter-title">t-분포의 통계적 기초</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#sec-independent-t-test" id="toc-sec-independent-t-test" class="nav-link active" data-scroll-target="#sec-independent-t-test"><span class="header-section-number">3.1</span> 3.1 독립표본 t-검정: 두 독립 집단의 평균 비교</a>
  <ul class="collapse">
  <li><a href="#독립표본-t-검정의-원리-가설-설정과-검정-통계량" id="toc-독립표본-t-검정의-원리-가설-설정과-검정-통계량" class="nav-link" data-scroll-target="#독립표본-t-검정의-원리-가설-설정과-검정-통계량"><span class="header-section-number">3.1.1</span> 3.1.1 독립표본 t-검정의 원리: 가설 설정과 검정 통계량</a></li>
  <li><a href="#독립표본-t-검정의-가정" id="toc-독립표본-t-검정의-가정" class="nav-link" data-scroll-target="#독립표본-t-검정의-가정"><span class="header-section-number">3.1.2</span> 3.1.2 독립표본 t-검정의 가정</a></li>
  <li><a href="#파이썬을-이용한-독립표본-t-검정-scipy.stats" id="toc-파이썬을-이용한-독립표본-t-검정-scipy.stats" class="nav-link" data-scroll-target="#파이썬을-이용한-독립표본-t-검정-scipy.stats"><span class="header-section-number">3.1.3</span> 3.1.3 파이썬을 이용한 독립표본 t-검정 (<code>scipy.stats</code>)</a></li>
  <li><a href="#효과-크기-계산-및-해석-cohens-d" id="toc-효과-크기-계산-및-해석-cohens-d" class="nav-link" data-scroll-target="#효과-크기-계산-및-해석-cohens-d"><span class="header-section-number">3.1.4</span> 3.1.4 효과 크기 계산 및 해석 (Cohen’s d)</a></li>
  <li><a href="#결과-보고" id="toc-결과-보고" class="nav-link" data-scroll-target="#결과-보고"><span class="header-section-number">3.1.5</span> 3.1.5 결과 보고</a></li>
  <li><a href="#요약-및-다음-단계" id="toc-요약-및-다음-단계" class="nav-link" data-scroll-target="#요약-및-다음-단계"><span class="header-section-number">3.1.6</span> 3.1.6 요약 및 다음 단계</a></li>
  </ul></li>
  <li><a href="#sec-paired-t-test" id="toc-sec-paired-t-test" class="nav-link" data-scroll-target="#sec-paired-t-test"><span class="header-section-number">3.2</span> 3.2 대응표본 t-검정: 동일 집단의 사전-사후 평균 비교</a>
  <ul class="collapse">
  <li><a href="#대응표본-t-검정의-원리-차이-점수와-가설-설정" id="toc-대응표본-t-검정의-원리-차이-점수와-가설-설정" class="nav-link" data-scroll-target="#대응표본-t-검정의-원리-차이-점수와-가설-설정"><span class="header-section-number">3.2.1</span> 3.2.1 대응표본 t-검정의 원리: 차이 점수와 가설 설정</a></li>
  <li><a href="#대응표본-t-검정의-가정" id="toc-대응표본-t-검정의-가정" class="nav-link" data-scroll-target="#대응표본-t-검정의-가정"><span class="header-section-number">3.2.2</span> 3.2.2 대응표본 t-검정의 가정</a></li>
  <li><a href="#파이썬을-이용한-대응표본-t-검정-scipy.stats" id="toc-파이썬을-이용한-대응표본-t-검정-scipy.stats" class="nav-link" data-scroll-target="#파이썬을-이용한-대응표본-t-검정-scipy.stats"><span class="header-section-number">3.2.3</span> 3.2.3 파이썬을 이용한 대응표본 t-검정 (<code>scipy.stats</code>)</a></li>
  <li><a href="#효과-크기-계산-및-해석-cohens-d-for-paired-samples" id="toc-효과-크기-계산-및-해석-cohens-d-for-paired-samples" class="nav-link" data-scroll-target="#효과-크기-계산-및-해석-cohens-d-for-paired-samples"><span class="header-section-number">3.2.4</span> 3.2.4 효과 크기 계산 및 해석 (Cohen’s d for Paired Samples)</a></li>
  <li><a href="#결과-보고-1" id="toc-결과-보고-1" class="nav-link" data-scroll-target="#결과-보고-1"><span class="header-section-number">3.2.5</span> 3.2.5 결과 보고</a></li>
  <li><a href="#요약-및-다음-단계-1" id="toc-요약-및-다음-단계-1" class="nav-link" data-scroll-target="#요약-및-다음-단계-1"><span class="header-section-number">3.2.6</span> 3.2.6 요약 및 다음 단계</a></li>
  </ul></li>
  <li><a href="#sec-one-way-anova" id="toc-sec-one-way-anova" class="nav-link" data-scroll-target="#sec-one-way-anova"><span class="header-section-number">3.3</span> 3.3 일원분산분석 (ANOVA): 세 개 이상 집단의 평균 비교</a>
  <ul class="collapse">
  <li><a href="#anova의-기본-원리-분산의-분해" id="toc-anova의-기본-원리-분산의-분해" class="nav-link" data-scroll-target="#anova의-기본-원리-분산의-분해"><span class="header-section-number">3.3.1</span> 3.3.1 ANOVA의 기본 원리: 분산의 분해</a></li>
  <li><a href="#f-통계량과-가설-검증" id="toc-f-통계량과-가설-검증" class="nav-link" data-scroll-target="#f-통계량과-가설-검증"><span class="header-section-number">3.3.2</span> 3.3.2 F-통계량과 가설 검증</a></li>
  <li><a href="#일원분산분석anova의-가정" id="toc-일원분산분석anova의-가정" class="nav-link" data-scroll-target="#일원분산분석anova의-가정"><span class="header-section-number">3.3.3</span> 3.3.3 일원분산분석(ANOVA)의 가정</a></li>
  <li><a href="#파이썬-statsmodels를-이용한-일원분산분석" id="toc-파이썬-statsmodels를-이용한-일원분산분석" class="nav-link" data-scroll-target="#파이썬-statsmodels를-이용한-일원분산분석"><span class="header-section-number">3.3.4</span> 3.3.4 파이썬 <code>statsmodels</code>를 이용한 일원분산분석</a></li>
  <li><a href="#효과-크기-계산-및-해석-에타-제곱-eta2" id="toc-효과-크기-계산-및-해석-에타-제곱-eta2" class="nav-link" data-scroll-target="#효과-크기-계산-및-해석-에타-제곱-eta2"><span class="header-section-number">3.3.5</span> 3.3.5 효과 크기 계산 및 해석 (에타 제곱, <span class="math inline">\(\eta^2\)</span>)</a></li>
  <li><a href="#사후-검정post-hoc-tests의-필요성" id="toc-사후-검정post-hoc-tests의-필요성" class="nav-link" data-scroll-target="#사후-검정post-hoc-tests의-필요성"><span class="header-section-number">3.3.6</span> 3.3.6 사후 검정(Post-Hoc Tests)의 필요성</a></li>
  <li><a href="#결과-보고-2" id="toc-결과-보고-2" class="nav-link" data-scroll-target="#결과-보고-2"><span class="header-section-number">3.3.7</span> 3.3.7 결과 보고</a></li>
  <li><a href="#요약" id="toc-요약" class="nav-link" data-scroll-target="#요약"><span class="header-section-number">3.3.8</span> 3.3.8 요약</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./03-group-difference-tests.html">제2부 - 집단 간 차이 분석 및 관계 분석</a></li><li class="breadcrumb-item"><a href="./03-group-difference-tests.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">제3장 집단 간 평균 차이 검증</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">제3장 집단 간 평균 차이 검증</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="sec-independent-t-test" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="sec-independent-t-test"><span class="header-section-number">3.1</span> 3.1 독립표본 t-검정: 두 독립 집단의 평균 비교</h2>
<p>앞선 2장에서는 데이터를 준비하고 탐색하는 기본적인 기술을 익혔습니다. 이제부터는 수집된 데이터를 바탕으로 구체적인 연구 질문에 답하는 통계적 추론의 세계로 나아갑니다. 제3부에서는 여러 집단 간의 차이나 변수 간의 관계를 통계적으로 검증하는 방법들을 다룹니다.</p>
<p>그 첫 번째 단계로, 사회과학 연구에서 매우 빈번하게 사용되는 <strong>독립표본 t-검정(Independent Samples t-test)</strong>에 대해 알아봅니다. 이 검정은 서로 <strong>독립적인 두 집단</strong> 간에 특정 <strong>연속형 변수의 평균</strong>에 통계적으로 유의미한 차이가 있는지를 확인하고자 할 때 사용됩니다.</p>
<p>예를 들어, 다음과 같은 연구 질문에 답하기 위해 독립표본 t-검정을 사용할 수 있습니다.</p>
<ul>
<li>성별(남성 vs 여성)에 따라 평균 소득에 차이가 있는가?</li>
<li>특정 정책 지지 집단과 반대 집단 간에 평균 정부 신뢰도 점수에 차이가 있는가?</li>
<li>실험 처치를 받은 집단(실험집단)과 받지 않은 집단(통제집단) 간에 평균 문제 해결 능력 점수에 차이가 있는가?</li>
</ul>
<p>독립표본 t-검정은 관찰된 두 표본 평균 간의 차이가 단순히 우연(표본 추출 오차)에 의한 것인지, 아니면 실제 모집단에서도 의미 있는 차이가 존재한다고 볼 수 있는지 통계적으로 판단하는 근거를 제공합니다.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
📌 핵심 요약
</div>
</div>
<div class="callout-body-container callout-body">
<p>독립표본 t-검정은 서로 독립적인 두 집단 간의 연속형 변수 평균 차이를 통계적으로 검증하는 방법입니다. 이 절에서는 t-검정의 기본 원리(가설 설정, t-통계량, p-값), 주요 가정(독립성, 정규성, 등분산성), 파이썬 <code>scipy.stats</code> 라이브러리를 이용한 구현 방법, 가정 검토(Shapiro-Wilk, Levene 검정), Welch’s t-검정의 활용, 결과 해석, 효과 크기(Cohen’s d) 계산 및 해석, 그리고 결과 보고 방법까지 학습합니다.</p>
</div>
</div>
<section id="독립표본-t-검정의-원리-가설-설정과-검정-통계량" class="level3" data-number="3.1.1">
<h3 data-number="3.1.1" class="anchored" data-anchor-id="독립표본-t-검정의-원리-가설-설정과-검정-통계량"><span class="header-section-number">3.1.1</span> 3.1.1 독립표본 t-검정의 원리: 가설 설정과 검정 통계량</h3>
<p>독립표본 t-검정은 가설 검증의 틀 안에서 이루어집니다.</p>
<ul>
<li><strong>가설 설정:</strong>
<ul>
<li><strong>귀무가설 (Null Hypothesis, <span class="math inline">\(H_0\)</span>):</strong> 두 집단의 모집단 평균은 같다 (<span class="math inline">\(H_0: \mu_1 = \mu_2\)</span> 또는 <span class="math inline">\(H_0: \mu_1 - \mu_2 = 0\)</span>). 즉, 우리가 표본에서 관찰한 평균 차이는 우연에 의한 것이다.</li>
<li><strong>대립가설 (Alternative Hypothesis, <span class="math inline">\(H_1\)</span>):</strong> 두 집단의 모집단 평균은 다르다 (<span class="math inline">\(H_1: \mu_1 \neq \mu_2\)</span>). 이 가설은 연구자가 입증하고자 하는 내용으로, 표본 평균 차이가 우연이라고 보기에는 너무 크다는 것을 의미합니다. 이는 <strong>양측 검정(Two-tailed test)</strong>에 해당합니다.
<ul>
<li>만약 연구자가 특정 방향의 차이(예: 집단 1이 집단 2보다 평균이 클 것이다)를 예측한다면 단측 검정(<span class="math inline">\(H_1: \mu_1 &gt; \mu_2\)</span> 또는 <span class="math inline">\(H_1: \mu_1 &lt; \mu_2\)</span>)을 설정할 수도 있지만, 특별한 근거가 없다면 일반적으로 양측 검정을 사용합니다.</li>
</ul></li>
</ul></li>
<li><strong>검정 통계량 (Test Statistic, t-value):</strong>
<ul>
<li>t-검정은 두 표본 평균 간의 차이를 표준 오차(Standard Error)로 나눈 값인 <strong>t-통계량</strong>을 계산합니다. 이는 관찰된 평균 차이가 그룹 내 변동성(오차)에 비해 얼마나 큰지를 나타내는 표준화된 값입니다.</li>
<li>개념적으로 t-값은 다음과 같이 표현될 수 있습니다: <span class="math inline">\(t = \frac{(\text{두 표본 평균의 차이}) - (\text{귀무가설 하에서의 평균 차이, 보통 0})}{(\text{두 평균 차이의 표준 오차})}\)</span> <span class="math inline">\(t = \frac{(\bar{x}_1 - \bar{x}_2)}{SE_{(\bar{x}_1 - \bar{x}_2)}}\)</span></li>
<li>t-값의 절댓값이 클수록 두 집단 간 평균 차이가 우연히 발생했을 가능성이 작아집니다.</li>
</ul></li>
<li><strong>p-값 (p-value):</strong>
<ul>
<li>p-값은 <strong>귀무가설(<span class="math inline">\(H_0\)</span>)이 참이라고 가정할 때</strong>, 우리가 표본에서 계산한 t-통계량 값 또는 그보다 더 극단적인 값이 관찰될 확률입니다.</li>
<li>p-값이 매우 작다(예: 0.05 미만)는 것은, 귀무가설이 맞다면 현재와 같은 표본 결과가 나타나기 매우 어렵다는 것을 의미합니다.</li>
</ul></li>
<li><strong>의사 결정:</strong>
<ul>
<li>미리 설정한 <strong>유의수준(Significance level, <span class="math inline">\(\alpha\)</span>)</strong>과 p-값을 비교하여 귀무가설 기각 여부를 결정합니다. 사회과학에서는 보통 <span class="math inline">\(\alpha = 0.05\)</span> (5%)를 사용합니다.</li>
<li><strong>p-값 &lt; <span class="math inline">\(\alpha\)</span> :</strong> 귀무가설(<span class="math inline">\(H_0\)</span>)을 기각하고 대립가설(<span class="math inline">\(H_1\)</span>)을 채택합니다. 즉, 두 집단 간 평균에 통계적으로 유의미한 차이가 있다고 결론 내립니다.</li>
<li><strong>p-값 <span class="math inline">\(\ge\)</span> <span class="math inline">\(\alpha\)</span> :</strong> 귀무가설(<span class="math inline">\(H_0\)</span>)을 기각하지 못합니다(채택하는 것이 아님). 즉, 두 집단 간 평균 차이가 통계적으로 유의미하다는 충분한 근거를 찾지 못했다고 결론 내립니다.</li>
</ul></li>
</ul>
</section>
<section id="독립표본-t-검정의-가정" class="level3" data-number="3.1.2">
<h3 data-number="3.1.2" class="anchored" data-anchor-id="독립표본-t-검정의-가정"><span class="header-section-number">3.1.2</span> 3.1.2 독립표본 t-검정의 가정</h3>
<p>독립표본 t-검정 결과를 신뢰하기 위해서는 몇 가지 가정이 충족되어야 합니다.</p>
<ol type="1">
<li><strong>독립성 (Independence of Observations):</strong> 한 집단 내의 관측치들은 서로 독립적이어야 하며, 두 집단 간의 관측치들도 서로 독립적이어야 합니다. 이는 주로 연구 설계 및 표본 추출 방법과 관련됩니다. (예: 무작위 할당, 무작위 표본 추출)</li>
<li><strong>정규성 (Normality):</strong> 종속변수는 <strong>각 집단별로</strong> 정규분포를 따라야 합니다.
<ul>
<li><strong>확인 방법:</strong> 각 집단별 히스토그램, Q-Q 플롯 확인(2.4절), 또는 정규성 검정(예: Shapiro-Wilk test) 수행.</li>
<li><strong>견고성(Robustness):</strong> 표본 크기가 충분히 크면(예: 각 집단별 30 이상), 중심극한정리(Central Limit Theorem)에 의해 t-검정은 정규성 가정 위반에 비교적 덜 민감합니다.</li>
</ul></li>
<li><strong>등분산성 (Homogeneity of Variances, Homoscedasticity):</strong> 두 집단의 모집단 분산이 동일해야 합니다.
<ul>
<li><strong>확인 방법:</strong> Levene의 등분산 검정(Levene’s test) 수행.</li>
<li><strong>중요성:</strong> 전통적인 Student’s t-test는 이 가정을 요구하지만, 이 가정이 충족되지 않을 때 사용할 수 있는 <strong>Welch’s t-test</strong>가 있습니다. Welch’s t-test는 등분산성 가정을 요구하지 않으며, 등분산성이 충족될 때에도 Student’s t-test와 유사한 결과를 제공하므로, <strong>많은 경우 Welch’s t-test를 기본으로 사용하는 것이 권장됩니다.</strong></li>
</ul></li>
</ol>
</section>
<section id="파이썬을-이용한-독립표본-t-검정-scipy.stats" class="level3" data-number="3.1.3">
<h3 data-number="3.1.3" class="anchored" data-anchor-id="파이썬을-이용한-독립표본-t-검정-scipy.stats"><span class="header-section-number">3.1.3</span> 3.1.3 파이썬을 이용한 독립표본 t-검정 (<code>scipy.stats</code>)</h3>
<p>파이썬의 <code>scipy.stats</code> 모듈은 독립표본 t-검정을 수행하는 <code>ttest_ind</code> 함수를 제공합니다. 2.5절에서 사용한 <code>df_practice</code> 데이터를 이용하여 성별(<code>Gender</code>)에 따른 소득(<code>Income</code>) 평균 차이가 있는지 검정해 보겠습니다.</p>
<p><strong>1. 데이터 준비:</strong> 먼저, 비교할 두 집단(남성, 여성)의 <code>Income</code> 데이터를 각각 추출합니다.</p>
<div id="4252275e" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy <span class="im">import</span> stats <span class="co"># t-test 및 관련 검정 함수 포함</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt <span class="co"># 가정 검토 시각화용 (선택적)</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns <span class="co"># 가정 검토 시각화용 (선택적)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># CSV 파일로부터 데이터 불러오기</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co"># 파일 경로는 실제 파일 위치에 맞게 수정해야 합니다.</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># csv_filepath = 'path/to/your/data_process.csv' # 실제 파일 경로로 수정</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    csv_filepath <span class="op">=</span> <span class="st">'data_process.csv'</span> <span class="co"># 2.5절에서 저장한 파일과 동일 디렉토리에 있다고 가정</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    df_processed <span class="op">=</span> pd.read_csv(csv_filepath, index_col<span class="op">=</span><span class="dv">0</span>) <span class="co"># index_col=0 추가</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"데이터 불러오기 성공!"</span>)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">--- 불러온 데이터 확인 (처음 5행) ---"</span>)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(df_processed.head())</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 데이터 타입 확인 (CSV 로딩 후 타입 변경 가능성 있음)</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">--- 불러온 데이터 정보 확인 ---"</span>)</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    df_processed.info()</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Education 변수 순서형 범주 타입 재지정 (필요시)</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> pd.api.types.is_categorical_dtype(df_processed[<span class="st">'Education'</span>]) <span class="kw">or</span> <span class="kw">not</span> df_processed[<span class="st">'Education'</span>].cat.ordered:</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Education 변수 타입을 순서형 범주(Ordered Categorical)로 재지정합니다."</span>)</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        edu_order <span class="op">=</span> [<span class="st">'High School'</span>, <span class="st">'Bachelor'</span>, <span class="st">'Master'</span>, <span class="st">'PhD'</span>]</span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>        df_processed[<span class="st">'Education'</span>] <span class="op">=</span> pd.Categorical(df_processed[<span class="st">'Education'</span>], categories<span class="op">=</span>edu_order, ordered<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>        df_processed.info() <span class="co"># 타입 변경 확인</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">FileNotFoundError</span>:</span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"오류: '</span><span class="sc">{</span>csv_filepath<span class="sc">}</span><span class="ss">' 파일을 찾을 수 없습니다."</span>)</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"2.5절에서 'data_process.csv' 파일이 정상적으로 저장되었는지, 파일 경로가 올바른지 확인해주세요."</span>)</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 예제 진행을 위해 중단 (실제 사용 시에는 파일 로딩 필수)</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">raise</span> <span class="co"># 오류 발생시키고 중단</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a><span class="co"># 성별에 따른 Income 데이터 분리 (이제 df_processed 사용)</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>male_income <span class="op">=</span> df_processed[df_processed[<span class="st">'Gender'</span>] <span class="op">==</span> <span class="st">'Male'</span>][<span class="st">'Income'</span>]</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>female_income <span class="op">=</span> df_processed[df_processed[<span class="st">'Gender'</span>] <span class="op">==</span> <span class="st">'Female'</span>][<span class="st">'Income'</span>]</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Male Income 데이터 개수: </span><span class="sc">{</span><span class="bu">len</span>(male_income)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Female Income 데이터 개수: </span><span class="sc">{</span><span class="bu">len</span>(female_income)<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>데이터 불러오기 성공!

--- 불러온 데이터 확인 (처음 5행) ---
   ID   Age  Gender    Education   Income  Wellbeing  Social_Participation  \
0   1  58.0  Female  High School  4666.08        4.1                     2   
1   2  48.0  Female          PhD  5308.40        0.4                     4   
2   3  34.0  Female     Bachelor  3159.16        8.5                     2   
3   4  62.0  Female     Bachelor  8500.52       10.4                     2   
4   5  27.0  Female       Master  3699.80        5.9                     2   

   Political_View  
0               7  
1               6  
2               2  
3               5  
4               2  

--- 불러온 데이터 정보 확인 ---
&lt;class 'pandas.core.frame.DataFrame'&gt;
Index: 100 entries, 0 to 99
Data columns (total 8 columns):
 #   Column                Non-Null Count  Dtype  
---  ------                --------------  -----  
 0   ID                    100 non-null    int64  
 1   Age                   100 non-null    float64
 2   Gender                100 non-null    object 
 3   Education             100 non-null    object 
 4   Income                100 non-null    float64
 5   Wellbeing             100 non-null    float64
 6   Social_Participation  100 non-null    int64  
 7   Political_View        100 non-null    int64  
dtypes: float64(3), int64(3), object(2)
memory usage: 7.0+ KB

Education 변수 타입을 순서형 범주(Ordered Categorical)로 재지정합니다.
&lt;class 'pandas.core.frame.DataFrame'&gt;
Index: 100 entries, 0 to 99
Data columns (total 8 columns):
 #   Column                Non-Null Count  Dtype   
---  ------                --------------  -----   
 0   ID                    100 non-null    int64   
 1   Age                   100 non-null    float64 
 2   Gender                100 non-null    object  
 3   Education             100 non-null    category
 4   Income                100 non-null    float64 
 5   Wellbeing             100 non-null    float64 
 6   Social_Participation  100 non-null    int64   
 7   Political_View        100 non-null    int64   
dtypes: category(1), float64(3), int64(3), object(1)
memory usage: 6.5+ KB

Male Income 데이터 개수: 50
Female Income 데이터 개수: 50</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Users\voidm\AppData\Local\Temp\ipykernel_34772\1887977693.py:23: DeprecationWarning:

is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, pd.CategoricalDtype) instead
</code></pre>
</div>
</div>
<p><strong>2. 가정 검토 (선택적이지만 권장):</strong></p>
<ul>
<li><strong>정규성 검토 (Shapiro-Wilk Test):</strong> 각 집단의 <code>Income</code> 데이터가 정규분포를 따르는지 확인합니다. 귀무가설(<span class="math inline">\(H_0\)</span>)은 ’데이터가 정규분포를 따른다’입니다.</li>
</ul>
<div id="0313c1fd" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 남성 Income 정규성 검정</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    shapiro_male <span class="op">=</span> stats.shapiro(male_income)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Shapiro-Wilk Test (Male Income): Statistic=</span><span class="sc">{</span>shapiro_male<span class="sc">.</span>statistic<span class="sc">:.3f}</span><span class="ss">, p-value=</span><span class="sc">{</span>shapiro_male<span class="sc">.</span>pvalue<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 여성 Income 정규성 검정</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    shapiro_female <span class="op">=</span> stats.shapiro(female_income)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Shapiro-Wilk Test (Female Income): Statistic=</span><span class="sc">{</span>shapiro_female<span class="sc">.</span>statistic<span class="sc">:.3f}</span><span class="ss">, p-value=</span><span class="sc">{</span>shapiro_female<span class="sc">.</span>pvalue<span class="sc">:.3f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Shapiro-Wilk Test (Male Income): Statistic=0.990, p-value=0.953
Shapiro-Wilk Test (Female Income): Statistic=0.989, p-value=0.931</code></pre>
</div>
</div>
<pre><code>* **해석:** 만약 p-값이 유의수준(예: 0.05)보다 크면, 정규분포를 따른다는 귀무가설을 기각할 수 없으므로 정규성 가정을 만족한다고 볼 수 있습니다. 만약 p-값이 0.05보다 작으면 정규성 가정이 위배될 수 있으나, 표본 크기가 충분히 크다면(예: 각 그룹 30 이상) t-검정은 여전히 사용 가능할 수 있습니다. 시각적 확인(히스토그램, Q-Q 플롯)을 병행하는 것이 좋습니다.</code></pre>
<ul>
<li><strong>등분산성 검토 (Levene’s Test):</strong> 두 집단의 분산이 동일한지 확인합니다. 귀무가설(<span class="math inline">\(H_0\)</span>)은 ’두 집단의 분산은 같다’입니다.</li>
</ul>
<div id="fef1c4a1" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 등분산성 검정 (Levene's Test)</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    levene_test <span class="op">=</span> stats.levene(male_income, female_income)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Levene's Test for Equal Variances: Statistic=</span><span class="sc">{</span>levene_test<span class="sc">.</span>statistic<span class="sc">:.3f}</span><span class="ss">, p-value=</span><span class="sc">{</span>levene_test<span class="sc">.</span>pvalue<span class="sc">:.3f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Levene's Test for Equal Variances: Statistic=0.013, p-value=0.910</code></pre>
</div>
</div>
<pre><code>* **해석:** 만약 p-값이 유의수준(예: 0.05)보다 크면, 등분산성 가정을 만족한다고 볼 수 있습니다 (`equal_var=True` 사용 가능). 만약 p-값이 0.05보다 작으면 등분산성 가정이 위배되므로 `equal_var=False` (Welch's t-test)를 사용해야 합니다.</code></pre>
<p><strong>3. t-검정 수행:</strong></p>
<p><code>scipy.stats.ttest_ind()</code> 함수를 사용합니다. <code>equal_var</code> 파라미터 설정이 중요합니다. Levene 검정 결과와 관계없이, 일반적으로 <strong><code>equal_var=False</code> (Welch’s t-test)를 사용하는 것이 더 안전하고 권장됩니다.</strong></p>
<div id="5e58bb1a" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 독립표본 t-검정 수행 (Welch's t-test 권장)</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Levene 검정 p-값이 0.05보다 크더라도 Welch's 사용 가능</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>t_statistic, p_value <span class="op">=</span> stats.ttest_ind(male_income, female_income, equal_var<span class="op">=</span><span class="va">False</span>) <span class="co"># Welch's t-test</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">--- Independent Samples t-test (Welch's) Results ---"</span>)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"T-statistic: </span><span class="sc">{</span>t_statistic<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"P-value: </span><span class="sc">{</span>p_value<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 참고: 만약 등분산성 가정이 충족되고 Student's t-test를 원한다면:</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="co"># t_stat_student, p_val_student = stats.ttest_ind(male_income, female_income, equal_var=True)</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="co"># print("\n--- Student's t-test Results (if assumptions met) ---")</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="co"># print(f"T-statistic: {t_stat_student:.3f}, P-value: {p_val_student:.3f}")</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
--- Independent Samples t-test (Welch's) Results ---
T-statistic: -0.475
P-value: 0.636</code></pre>
</div>
</div>
<p><strong>4. 결과 해석:</strong></p>
<p>계산된 t-통계량과 p-값을 바탕으로 결론을 내립니다. 유의수준 <span class="math inline">\(\alpha = 0.05\)</span>를 기준으로 판단합니다.</p>
<ul>
<li><strong>해석 (예시 결과 기반):</strong> 만약 위 코드 실행 결과 <code>p_value</code>가 0.05보다 작게 나왔다면 (예: <code>p_value = 0.021</code>), 다음과 같이 해석합니다.
<ul>
<li>“독립표본 t-검정(Welch’s) 결과, 성별에 따른 평균 소득에는 통계적으로 유의미한 차이가 있는 것으로 나타났다 (t = [t-값], p = 0.021). 유의수준 0.05에서 귀무가설(‘남성과 여성의 평균 소득은 같다’)을 기각한다.”</li>
</ul></li>
<li>만약 <code>p_value</code>가 0.05보다 크거나 같게 나왔다면 (예: <code>p_value = 0.350</code>), 다음과 같이 해석합니다.
<ul>
<li>“독립표본 t-검정(Welch’s) 결과, 성별에 따른 평균 소득 차이는 통계적으로 유의미하지 않았다 (t = [t-값], p = 0.350). 유의수준 0.05에서 귀무가설(‘남성과 여성의 평균 소득은 같다’)을 기각할 충분한 근거를 찾지 못했다.”</li>
</ul></li>
</ul>
<p><strong>중요:</strong> 통계적 유의성은 ’차이가 존재한다/하지 않는다’는 증거의 강도를 말해줄 뿐, 그 차이가 <strong>실질적으로 얼마나 크고 중요한지</strong>는 별도로 평가해야 합니다. 이를 위해 <strong>효과 크기(Effect Size)</strong>를 확인합니다.</p>
</section>
<section id="효과-크기-계산-및-해석-cohens-d" class="level3" data-number="3.1.4">
<h3 data-number="3.1.4" class="anchored" data-anchor-id="효과-크기-계산-및-해석-cohens-d"><span class="header-section-number">3.1.4</span> 3.1.4 효과 크기 계산 및 해석 (Cohen’s d)</h3>
<p>효과 크기는 두 집단 간 평균 차이의 <strong>크기(magnitude)</strong>를 나타내는 표준화된 지표입니다. 표본 크기에 영향을 덜 받으며, 결과의 실질적인 중요성을 평가하는 데 도움을 줍니다. t-검정에서는 <strong>Cohen’s d</strong>가 널리 사용됩니다.</p>
<ul>
<li><p><strong>Cohen’s d 정의:</strong> 두 집단 평균의 차이를 합동 표준편차(pooled standard deviation)로 나눈 값입니다. <span class="math inline">\(d = \frac{|\bar{x}_1 - \bar{x}_2|}{s_p}\)</span> (여기서 <span class="math inline">\(s_p\)</span>는 두 집단의 표준편차를 고려한 합동 표준편차입니다. Welch’s t-test의 경우 약간 다른 방식으로 계산될 수 있으나, 개념은 유사합니다.)</p></li>
<li><p><strong>Cohen’s d 해석 기준 (일반적 가이드라인):</strong></p>
<ul>
<li><span class="math inline">\(|d| \approx 0.2\)</span>: 작은 효과 크기</li>
<li><span class="math inline">\(|d| \approx 0.5\)</span>: 중간 효과 크기</li>
<li><span class="math inline">\(|d| \approx 0.8\)</span>: 큰 효과 크기</li>
</ul></li>
<li><p><strong>파이썬으로 Cohen’s d 계산 (수동 계산 예시):</strong></p></li>
</ul>
<div id="6f7cc605" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Cohen's d 계산 함수 (Welch's t-test에 근사)</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> cohens_d(group1, group2):</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 그룹별 평균, 표준편차, 샘플 사이즈</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>        mean1, mean2 <span class="op">=</span> np.mean(group1), np.mean(group2)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        std1, std2 <span class="op">=</span> np.std(group1, ddof<span class="op">=</span><span class="dv">1</span>), np.std(group2, ddof<span class="op">=</span><span class="dv">1</span>) <span class="co"># ddof=1 for sample std dev</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        n1, n2 <span class="op">=</span> <span class="bu">len</span>(group1), <span class="bu">len</span>(group2)</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 합동 표준편차 (Welch's t-test는 분산이 다르다고 가정하므로, 약간의 근사 사용)</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 간단하게는 전체 샘플의 표준편차 또는 더 복잡한 공식을 사용할 수 있으나, 여기서는 근사치로 계산</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        <span class="co"># (정확한 Welch's d 계산은 복잡할 수 있음)</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 평균 표준편차 사용 (간단한 근사)</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>        <span class="co"># pooled_std = np.sqrt((std1**2 + std2**2) / 2)</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># 또는 더 일반적인 합동 표준편차 (등분산 가정 시)</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        pooled_std <span class="op">=</span> np.sqrt(((n1 <span class="op">-</span> <span class="dv">1</span>) <span class="op">*</span> std1<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> (n2 <span class="op">-</span> <span class="dv">1</span>) <span class="op">*</span> std2<span class="op">**</span><span class="dv">2</span>) <span class="op">/</span> (n1 <span class="op">+</span> n2 <span class="op">-</span> <span class="dv">2</span>))</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>        d <span class="op">=</span> (mean1 <span class="op">-</span> mean2) <span class="op">/</span> pooled_std</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">abs</span>(d) <span class="co"># 효과 크기는 보통 절댓값으로 표현</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Income by Gender Cohen's d 계산</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>    d_income_gender <span class="op">=</span> cohens_d(male_income, female_income)</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Cohen's d for Income difference between Genders: </span><span class="sc">{</span>d_income_gender<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 해석 (예시)</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> d_income_gender <span class="op">&lt;</span> <span class="fl">0.2</span>:</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a>      effect_size_interpretation <span class="op">=</span> <span class="st">"매우 작음 (trivial)"</span></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> d_income_gender <span class="op">&lt;</span> <span class="fl">0.5</span>:</span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>      effect_size_interpretation <span class="op">=</span> <span class="st">"작음 (small)"</span></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> d_income_gender <span class="op">&lt;</span> <span class="fl">0.8</span>:</span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a>      effect_size_interpretation <span class="op">=</span> <span class="st">"중간 (medium)"</span></span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a>      effect_size_interpretation <span class="op">=</span> <span class="st">"큼 (large)"</span></span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"효과 크기 해석: </span><span class="sc">{</span>effect_size_interpretation<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Cohen's d for Income difference between Genders: 0.095
효과 크기 해석: 매우 작음 (trivial)</code></pre>
</div>
</div>
<pre><code>**참고:** `pingouin`과 같은 다른 통계 라이브러리는 `pg.ttest()` 함수 내에서 Cohen's d를 직접 계산해주는 기능을 제공하기도 합니다.</code></pre>
</section>
<section id="결과-보고" class="level3" data-number="3.1.5">
<h3 data-number="3.1.5" class="anchored" data-anchor-id="결과-보고"><span class="header-section-number">3.1.5</span> 3.1.5 결과 보고</h3>
<p>t-검정 결과를 논문이나 보고서에 제시할 때는 다음과 같은 정보들을 포함하는 것이 일반적입니다 (APA 스타일 등 참고).</p>
<ol type="1">
<li>비교 대상인 두 집단.</li>
<li>비교 대상인 종속변수.</li>
<li>각 집단의 평균(M)과 표준편차(SD).</li>
<li>사용한 t-검정의 종류 (예: 독립표본 t-검정, Welch’s t-검정).</li>
<li>t-통계량 값과 자유도(degree of freedom, df). <code>scipy.stats.ttest_ind</code>는 Welch’s t-test의 경우 정확한 자유도를 반환하지 않지만, 다른 라이브러리나 수동 계산을 통해 얻을 수 있습니다. 여기서는 생략하거나 t-값만 제시할 수 있습니다. (참고: <code>pingouin</code> 라이브러리는 df를 제공합니다.)</li>
<li>p-값 (정확한 값 또는 &lt; .05, &lt; .01 등으로 표기).</li>
<li>효과 크기 (예: Cohen’s d).</li>
</ol>
<ul>
<li><strong>보고 예시 (위 예시 결과가 유의미했다고 가정):</strong> “성별에 따른 평균 소득 차이를 분석하기 위해 독립표본 t-검정(Welch’s)을 실시하였다. 분석 결과, 남성 집단(M = [남성평균], SD = [남성표준편차])의 평균 소득이 여성 집단(M = [여성평균], SD = [여성표준편차])보다 통계적으로 유의미하게 높은 것으로 나타났다 (t ≈ [t-값], p = [p-값]). 이 차이의 효과 크기는 Cohen’s d = [d-값]로, [작은/중간/큰] 수준의 효과에 해당한다.”</li>
</ul>
</section>
<section id="요약-및-다음-단계" class="level3" data-number="3.1.6">
<h3 data-number="3.1.6" class="anchored" data-anchor-id="요약-및-다음-단계"><span class="header-section-number">3.1.6</span> 3.1.6 요약 및 다음 단계</h3>
<p>이번 절에서는 서로 독립적인 두 집단 간의 평균 차이를 검증하는 강력한 도구인 독립표본 t-검정에 대해 배웠습니다. 가설 설정부터 파이썬 코드 구현, 가정 검토, 결과 해석, 효과 크기 계산, 그리고 결과 보고 방법까지 전 과정을 살펴보았습니다.</p>
<p><strong>핵심 사항:</strong></p>
<ul>
<li>독립표본 t-검정은 <strong>두 독립 집단</strong>의 <strong>연속형 변수 평균</strong> 비교에 사용됩니다.</li>
<li><strong>가정(독립성, 정규성, 등분산성)</strong>을 확인하는 것이 중요하며, 특히 등분산성 가정이 충족되지 않을 경우 <strong>Welch’s t-test (<code>equal_var=False</code>)</strong> 사용이 권장됩니다.</li>
<li><strong>p-값</strong>은 통계적 유의성을 판단하는 기준이며, <strong>효과 크기(Cohen’s d)</strong>는 차이의 실제적인 크기를 나타냅니다. 두 가지 모두 해석에 중요합니다.</li>
</ul>
<p><strong>한계점:</strong> 독립표본 t-검정은 비교 집단이 <strong>두 개</strong>일 경우에만 사용할 수 있습니다. 또한, 평균 비교 외에 다른 정보(예: 분포 형태)는 고려하지 않습니다.</p>
<p>다음 절(3.2)에서는 <strong>동일한 집단</strong>에서 얻어진 두 측정값(예: 사전-사후 점수)의 평균 차이를 비교하는 <strong>대응표본 t-검정(Paired Samples t-test)</strong>에 대해 알아보겠습니다.</p>
</section>
</section>
<section id="sec-paired-t-test" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="sec-paired-t-test"><span class="header-section-number">3.2</span> 3.2 대응표본 t-검정: 동일 집단의 사전-사후 평균 비교</h2>
<p>앞선 3.1절에서는 서로 다른 두 독립 집단 간의 평균을 비교하는 독립표본 t-검정에 대해 알아보았습니다. 하지만 연구 상황에 따라서는 <strong>동일한 집단</strong>을 대상으로 특정 처치(intervention)나 시간 경과에 따른 변화를 측정하거나, 혹은 부부, 형제 등과 같이 자연적으로 또는 인위적으로 <strong>짝지어진 대상</strong> 간의 차이를 비교해야 할 필요가 있습니다. 예를 들어, 어떤 교육 프로그램의 효과를 알아보기 위해 참여자들의 사전 점수와 사후 점수를 비교하는 경우가 이에 해당합니다.</p>
<p>이처럼 <strong>두 변수가 서로 독립이 아닌, 관련되어 있는 경우(related observations)</strong> 또는 <strong>반복 측정된(repeated measures)</strong> 경우의 평균 차이를 검증할 때 사용하는 방법이 바로 <strong>대응표본 t-검정(Paired Samples t-test)</strong>입니다. 이는 종속표본 t-검정(Dependent Samples t-test) 또는 반복측정 t-검정(Repeated Measures t-test)이라고도 불립니다.</p>
<p>대응표본 t-검정은 다음과 같은 연구 질문에 답하는 데 사용될 수 있습니다.</p>
<ul>
<li>특정 교육 프로그램 실시 후 참여자들의 학업 성취도 점수가 실시 전보다 유의미하게 향상되었는가? (사전-사후 비교)</li>
<li>새로운 광고 시청 전후 소비자들의 제품 선호도 점수에 유의미한 변화가 있었는가? (사전-사후 비교)</li>
<li>동일한 참가자가 조용한 환경과 소음 환경에서 각각 수행한 집중력 테스트 점수 간에 유의미한 차이가 있는가? (두 가지 조건 비교)</li>
<li>부부(짝지어진 쌍) 간의 결혼 만족도 점수에 유의미한 차이가 있는가? (짝지어진 대상 비교)</li>
</ul>
<p>핵심 아이디어는 각 쌍(pair) 내의 <strong>차이 점수(difference score)</strong>를 계산하고, 이 차이 점수들의 평균이 0과 통계적으로 유의미하게 다른지를 검증하는 것입니다.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
📌 핵심 요약
</div>
</div>
<div class="callout-body-container callout-body">
<p>대응표본 t-검정은 동일 집단의 반복 측정값(예: 사전-사후) 또는 짝지어진 대상 간의 평균 차이를 통계적으로 검증합니다. 이 절에서는 대응표본 t-검정의 핵심 원리(차이 점수 활용, 가설 설정), 가정(관측치 쌍의 독립성, 차이 점수의 정규성), 파이썬 <code>scipy.stats</code>의 <code>ttest_rel</code> 함수를 이용한 구현, 결과 해석, 효과 크기(Cohen’s <span class="math inline">\(d_z\)</span>) 계산 및 해석, 그리고 결과 보고 방법을 학습합니다.</p>
</div>
</div>
<section id="대응표본-t-검정의-원리-차이-점수와-가설-설정" class="level3" data-number="3.2.1">
<h3 data-number="3.2.1" class="anchored" data-anchor-id="대응표본-t-검정의-원리-차이-점수와-가설-설정"><span class="header-section-number">3.2.1</span> 3.2.1 대응표본 t-검정의 원리: 차이 점수와 가설 설정</h3>
<p>대응표본 t-검정은 두 번 측정된 값들 간의 <strong>차이 점수(difference score)</strong>를 계산하는 것에서 시작합니다. 각 개체(또는 쌍) <span class="math inline">\(i\)</span>에 대해 <span class="math inline">\(d_i = x_{i, \text{측정2}} - x_{i, \text{측정1}}\)</span> (예: <span class="math inline">\(d_i = x_{i, \text{사후}} - x_{i, \text{사전}}\)</span>)를 계산합니다.</p>
<p>이렇게 계산된 <strong>차이 점수(<span class="math inline">\(d_i\)</span>)들</strong>은 이제 하나의 표본을 이룹니다. 대응표본 t-검정은 본질적으로 이 <strong>차이 점수 표본의 평균(<span class="math inline">\(\bar{d}\)</span>)이 0과 유의미하게 다른지</strong>를 검증하는 <strong>단일 표본 t-검정(One-sample t-test)</strong>과 동일한 원리로 작동합니다.</p>
<ul>
<li><strong>가설 설정 (차이 점수의 평균 <span class="math inline">\(\mu_d\)</span>에 대해):</strong>
<ul>
<li><strong>귀무가설 (<span class="math inline">\(H_0: \mu_d = 0\)</span>):</strong> 모집단에서 두 측정 시점(또는 조건) 간 평균 차이는 0이다. (즉, 변화 또는 차이가 없다.)</li>
<li><strong>대립가설 (<span class="math inline">\(H_1: \mu_d \neq 0\)</span>):</strong> 모집단에서 두 측정 시점(또는 조건) 간 평균 차이는 0이 아니다. (즉, 변화 또는 차이가 있다.) - 양측 검정 기준.
<ul>
<li>특정 방향의 변화(예: 점수 향상, <span class="math inline">\(\mu_d &gt; 0\)</span>)를 예측하는 경우 단측 검정(<span class="math inline">\(H_1: \mu_d &gt; 0\)</span> 또는 <span class="math inline">\(H_1: \mu_d &lt; 0\)</span>)을 설정할 수 있습니다.</li>
</ul></li>
</ul></li>
<li><strong>검정 통계량 (Test Statistic, t-value):</strong>
<ul>
<li>차이 점수들의 표본 평균(<span class="math inline">\(\bar{d}\)</span>)과 표본 표준편차(<span class="math inline">\(s_d\)</span>)를 이용하여 t-통계량을 계산합니다. 이는 단일 표본 t-통계량 공식과 동일합니다. <span class="math display">\[t = \frac{\bar{d} - \mu_d}{SE_{\bar{d}}} = \frac{\bar{d} - 0}{s_d / \sqrt{n}} = \frac{\bar{d}}{s_d / \sqrt{n}}\]</span></li>
<li>여기서 <span class="math inline">\(\bar{d}\)</span>는 차이 점수들의 평균, <span class="math inline">\(s_d\)</span>는 차이 점수들의 표본 표준편차, <span class="math inline">\(n\)</span>은 <strong>쌍의 개수(number of pairs)</strong>입니다.</li>
<li>이 t-통계량은 자유도 <span class="math inline">\(df = n - 1\)</span>인 t-분포를 따릅니다.</li>
</ul></li>
<li><strong>p-값 (p-value) 및 의사 결정:</strong>
<ul>
<li>계산된 t-통계량과 해당 자유도(<span class="math inline">\(df=n-1\)</span>)의 t-분포를 이용하여 p-값을 계산합니다.</li>
<li>유의수준 <span class="math inline">\(\alpha\)</span>(보통 0.05)와 p-값을 비교하여 귀무가설 기각 여부를 결정하는 방식은 독립표본 t-검정과 동일합니다. (p-값 &lt; <span class="math inline">\(\alpha\)</span> 이면 <span class="math inline">\(H_0\)</span> 기각)</li>
</ul></li>
</ul>
</section>
<section id="대응표본-t-검정의-가정" class="level3" data-number="3.2.2">
<h3 data-number="3.2.2" class="anchored" data-anchor-id="대응표본-t-검정의-가정"><span class="header-section-number">3.2.2</span> 3.2.2 대응표본 t-검정의 가정</h3>
<p>대응표본 t-검정 결과를 신뢰하기 위한 주요 가정은 다음과 같습니다.</p>
<ol type="1">
<li><strong>관측치의 쌍 (Paired Observations):</strong> 데이터는 반드시 쌍으로 이루어져야 합니다 (예: 동일 대상 반복 측정, 짝지어진 대상). 각 쌍 내의 두 값은 서로 관련되어 있습니다.</li>
<li><strong>표본의 독립성 (Independence of Pairs):</strong> 각 <strong>쌍(pair)</strong>은 다른 쌍과 서로 독립적이어야 합니다. 한 쌍의 측정 결과가 다른 쌍의 결과에 영향을 주지 않아야 합니다.</li>
<li><strong>차이 점수의 정규성 (Normality of Differences):</strong> <strong>두 측정값 간의 차이 점수(<span class="math inline">\(d_i\)</span>)</strong>가 정규분포를 따라야 합니다. 이는 원시 점수(<span class="math inline">\(x_{i,1}, x_{i,2}\)</span>) 자체가 정규분포를 따를 필요는 없다는 점에서 독립표본 t-검정의 정규성 가정과 차이가 있습니다.
<ul>
<li><strong>확인 방법:</strong> 차이 점수(<span class="math inline">\(d_i\)</span>)에 대해 히스토그램, Q-Q 플롯을 그리거나 Shapiro-Wilk 검정을 수행합니다.</li>
<li><strong>견고성:</strong> 차이 점수의 표본 크기(<span class="math inline">\(n\)</span>, 즉 쌍의 개수)가 충분히 크면(예: 30 이상), 중심극한정리에 의해 정규성 가정을 다소 위반하더라도 t-검정은 비교적 강건(robust)합니다.</li>
</ul></li>
</ol>
</section>
<section id="파이썬을-이용한-대응표본-t-검정-scipy.stats" class="level3" data-number="3.2.3">
<h3 data-number="3.2.3" class="anchored" data-anchor-id="파이썬을-이용한-대응표본-t-검정-scipy.stats"><span class="header-section-number">3.2.3</span> 3.2.3 파이썬을 이용한 대응표본 t-검정 (<code>scipy.stats</code>)</h3>
<p>파이썬 <code>scipy.stats</code> 모듈의 <code>ttest_rel</code> 함수를 사용하여 대응표본 t-검정을 수행할 수 있습니다. 또는 차이 점수를 계산하여 <code>ttest_1samp</code> 함수를 사용할 수도 있습니다.</p>
<p><strong>1. 가상 데이터 생성:</strong> 특정 스트레스 감소 프로그램의 효과를 검증하는 상황을 가정하여, 25명의 참가자를 대상으로 프로그램 참여 전(<code>Stress_Pre</code>)과 후(<code>Stress_Post</code>)의 스트레스 점수를 측정한 가상 데이터를 생성합니다.</p>
<div id="cc20cafc" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy <span class="im">import</span> stats</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="co"># 재현 가능성을 위한 시드 설정</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>np.random.seed(<span class="dv">123</span>)</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="co"># 데이터 생성 (N=25 pairs)</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>n_pairs <span class="op">=</span> <span class="dv">25</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="co"># 사전 스트레스 점수 시뮬레이션 (평균 7, 표준편차 1.5)</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>stress_pre <span class="op">=</span> np.random.normal(loc<span class="op">=</span><span class="fl">7.0</span>, scale<span class="op">=</span><span class="fl">1.5</span>, size<span class="op">=</span>n_pairs)</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a><span class="co"># 사후 스트레스 점수 시뮬레이션 (평균적으로 1.0 감소, 개인차 반영)</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a><span class="co"># pre 점수와 약간의 양의 상관관계 가지도록 노이즈 조절</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>stress_post <span class="op">=</span> stress_pre <span class="op">-</span> np.random.normal(loc<span class="op">=</span><span class="fl">1.0</span>, scale<span class="op">=</span><span class="fl">0.8</span>, size<span class="op">=</span>n_pairs) <span class="op">+</span> np.random.normal(loc<span class="op">=</span><span class="dv">0</span>, scale<span class="op">=</span><span class="fl">0.5</span>, size<span class="op">=</span>n_pairs)</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a><span class="co"># 점수 범위를 1~10 사이로 제한 (현실성 반영)</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>stress_pre <span class="op">=</span> np.clip(stress_pre, <span class="dv">1</span>, <span class="dv">10</span>).<span class="bu">round</span>(<span class="dv">1</span>)</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>stress_post <span class="op">=</span> np.clip(stress_post, <span class="dv">1</span>, <span class="dv">10</span>).<span class="bu">round</span>(<span class="dv">1</span>)</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a><span class="co"># DataFrame 생성</span></span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>df_paired <span class="op">=</span> pd.DataFrame({<span class="st">'ID'</span>: <span class="bu">range</span>(<span class="dv">1</span>, n_pairs <span class="op">+</span> <span class="dv">1</span>),</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>                          <span class="st">'Stress_Pre'</span>: stress_pre,</span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>                          <span class="st">'Stress_Post'</span>: stress_post})</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a><span class="co"># 분석의 핵심인 '차이 점수' 계산 (Post - Pre)</span></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>df_paired[<span class="st">'Stress_Diff'</span>] <span class="op">=</span> df_paired[<span class="st">'Stress_Post'</span>] <span class="op">-</span> df_paired[<span class="st">'Stress_Pre'</span>]</span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"--- 가상 대응표본 데이터 (스트레스 점수) ---"</span>)</span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df_paired.head())</span>
<span id="cb15-32"><a href="#cb15-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">데이터 크기: </span><span class="sc">{</span>df_paired<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> 쌍"</span>)</span>
<span id="cb15-33"><a href="#cb15-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-34"><a href="#cb15-34" aria-hidden="true" tabindex="-1"></a><span class="co"># 차이 점수 기술 통계 확인</span></span>
<span id="cb15-35"><a href="#cb15-35" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">--- 차이 점수(Stress_Diff) 기술 통계 ---"</span>)</span>
<span id="cb15-36"><a href="#cb15-36" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(df_paired[<span class="st">'Stress_Diff'</span>].describe())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>--- 가상 대응표본 데이터 (스트레스 점수) ---
   ID  Stress_Pre  Stress_Post  Stress_Diff
0   1         5.4          4.2         -1.2
1   2         8.5          6.3         -2.2
2   3         7.4          8.4          1.0
3   4         4.7          3.5         -1.2
4   5         6.1          5.8         -0.3

데이터 크기: 25 쌍

--- 차이 점수(Stress_Diff) 기술 통계 ---
count    25.000000
mean     -0.868000
std       1.281184
min      -3.800000
25%      -1.300000
50%      -0.800000
75%      -0.300000
max       1.600000
Name: Stress_Diff, dtype: float64</code></pre>
</div>
</div>
<ul>
<li><strong>해석:</strong> <code>Stress_Diff</code>의 평균이 음수(-) 값을 가지므로, 평균적으로 사후 점수가 사전 점수보다 낮아졌음을 시사합니다. 대응표본 t-검정은 이 평균 차이가 통계적으로 유의미한지(즉, 0과 유의하게 다른지) 검증합니다.</li>
</ul>
<p><strong>2. 가정 검토 (차이 점수의 정규성):</strong> 차이 점수(<code>Stress_Diff</code>)가 정규분포를 따르는지 Shapiro-Wilk 검정으로 확인합니다.</p>
<div id="0920b385" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 차이 점수의 정규성 검정 (Shapiro-Wilk Test)</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>shapiro_diff <span class="op">=</span> stats.shapiro(df_paired[<span class="st">'Stress_Diff'</span>])</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Shapiro-Wilk Test (Stress Differences): Statistic=</span><span class="sc">{</span>shapiro_diff<span class="sc">.</span>statistic<span class="sc">:.3f}</span><span class="ss">, p-value=</span><span class="sc">{</span>shapiro_diff<span class="sc">.</span>pvalue<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="co"># 시각적 확인 (히스토그램)</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">7</span>, <span class="dv">5</span>))</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>sns.histplot(df_paired[<span class="st">'Stress_Diff'</span>], kde<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Distribution of Stress Score Differences (Post - Pre)'</span>)</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Stress Difference'</span>)</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Frequency'</span>)</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Shapiro-Wilk Test (Stress Differences): Statistic=0.971, p-value=0.677</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="03-group-difference-tests_files/figure-html/cell-8-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<ul>
<li><strong>해석:</strong> Shapiro-Wilk 검정의 p-값이 유의수준(0.05)보다 크면 정규성 가정을 만족한다고 볼 수 있습니다. 히스토그램이나 Q-Q 플롯을 통해 시각적으로도 분포 형태를 확인하는 것이 좋습니다. (예시 데이터는 정규분포에서 생성했으므로 가정이 충족될 가능성이 높습니다.)</li>
</ul>
<p><strong>3. 대응표본 t-검정 수행:</strong></p>
<ul>
<li><strong>방법 1: <code>ttest_rel</code> 사용 (권장):</strong> 사전 점수 배열과 사후 점수 배열을 직접 인자로 전달합니다.</li>
</ul>
<div id="8df9b962" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 방법 1: ttest_rel 사용</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    t_statistic_rel, p_value_rel <span class="op">=</span> stats.ttest_rel(df_paired[<span class="st">'Stress_Pre'</span>], df_paired[<span class="st">'Stress_Post'</span>])</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">--- Paired Samples t-test (ttest_rel) Results ---"</span>)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"T-statistic: </span><span class="sc">{</span>t_statistic_rel<span class="sc">:.3f}</span><span class="ss">"</span>) <span class="co"># Pre가 Post보다 크면 양수, Post가 Pre보다 크면 음수</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"P-value: </span><span class="sc">{</span>p_value_rel<span class="sc">:.3f}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
--- Paired Samples t-test (ttest_rel) Results ---
T-statistic: 3.387
P-value: 0.002</code></pre>
</div>
</div>
<pre><code>* **주의:** `ttest_rel(a, b)`는 `a - b`의 차이를 기준으로 검정합니다. 즉, `ttest_rel(Stress_Pre, Stress_Post)`는 '사전 점수 - 사후 점수'의 평균이 0인지 검정합니다. 따라서 t-값이 양수이면 사전 점수가 평균적으로 더 높다는 의미입니다. 만약 '사후 - 사전' 차이를 검정하고 싶다면 순서를 바꾸거나(`ttest_rel(Stress_Post, Stress_Pre)`) 아래의 방법 2를 사용합니다.</code></pre>
<ul>
<li><strong>방법 2: <code>ttest_1samp</code> 사용 (개념 이해에 유용):</strong> 차이 점수(<code>Stress_Diff</code>)에 대해 평균이 0인지 단일 표본 t-검정을 수행합니다.</li>
</ul>
<div id="3fa320ae" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 방법 2: 차이 점수에 대한 단일 표본 t-검정 (ttest_1samp)</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># H0: mean(Stress_Diff) = 0</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    t_statistic_1samp, p_value_1samp <span class="op">=</span> stats.ttest_1samp(df_paired[<span class="st">'Stress_Diff'</span>], popmean<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">--- One-Sample t-test on Differences (ttest_1samp) Results ---"</span>)</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"T-statistic: </span><span class="sc">{</span>t_statistic_1samp<span class="sc">:.3f}</span><span class="ss">"</span>) <span class="co"># Post-Pre 차이의 평균이 0보다 작으면 음수</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"P-value: </span><span class="sc">{</span>p_value_1samp<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 결과 비교 확인 (ttest_rel과 t-값 부호, p-값 동일성)</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">비교: ttest_rel의 t값 부호 반대: </span><span class="sc">{</span><span class="op">-</span>t_statistic_rel<span class="sc">:.3f}</span><span class="ss">"</span>) <span class="co"># ttest_rel은 Pre-Post 기준이므로 부호 반대</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"비교: 두 방법의 p-value는 동일해야 함: </span><span class="sc">{</span>p_value_rel <span class="op">==</span> p_value_1samp<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
--- One-Sample t-test on Differences (ttest_1samp) Results ---
T-statistic: -3.387
P-value: 0.002

비교: ttest_rel의 t값 부호 반대: -3.387
비교: 두 방법의 p-value는 동일해야 함: True</code></pre>
</div>
</div>
<p><strong>4. 결과 해석:</strong> 계산된 t-통계량과 p-값을 바탕으로 결론을 내립니다 (<span class="math inline">\(\alpha = 0.05\)</span> 기준).</p>
<ul>
<li><strong>해석 (예시 결과 기반, <code>ttest_1samp</code> 결과 사용):</strong> 만약 위 코드 실행 결과 <code>p_value_1samp</code>가 0.05보다 매우 작게 나왔다면 (예: <code>p_value = 0.001</code>), 다음과 같이 해석합니다.
<ul>
<li>“대응표본 t-검정 결과, 스트레스 감소 프로그램 참여 후 스트레스 점수(M=[사후평균], SD=[사후표준편차])는 참여 전(M=[사전평균], SD=[사전표준편차])에 비해 통계적으로 유의미하게 감소하였다 (t([df=n-1]) = [t-값], p = 0.001). 유의수준 0.05에서 귀무가설(‘프로그램 참여 전후 스트레스 점수 평균 차이는 0이다’)을 기각한다.”</li>
</ul></li>
<li>만약 <code>p_value_1samp</code>가 0.05보다 크거나 같게 나왔다면 (예: <code>p_value = 0.150</code>), 다음과 같이 해석합니다.
<ul>
<li>“대응표본 t-검정 결과, 스트레스 감소 프로그램 참여 전후의 스트레스 점수 간 평균 차이는 통계적으로 유의미하지 않았다 (t([df=n-1]) = [t-값], p = 0.150). 유의수준 0.05에서 귀무가설을 기각할 충분한 근거를 찾지 못했다.”</li>
</ul></li>
</ul>
</section>
<section id="효과-크기-계산-및-해석-cohens-d-for-paired-samples" class="level3" data-number="3.2.4">
<h3 data-number="3.2.4" class="anchored" data-anchor-id="효과-크기-계산-및-해석-cohens-d-for-paired-samples"><span class="header-section-number">3.2.4</span> 3.2.4 효과 크기 계산 및 해석 (Cohen’s d for Paired Samples)</h3>
<p>대응표본 t-검정에서도 통계적 유의성 외에 <strong>차이의 크기</strong>를 평가하기 위해 효과 크기를 계산합니다. 주로 <strong>Cohen’s <span class="math inline">\(d_z\)</span></strong> 를 사용하며, 이는 <strong>차이 점수들의 평균(<span class="math inline">\(\bar{d}\)</span>)</strong>을 <strong>차이 점수들의 표준편차(<span class="math inline">\(s_d\)</span>)</strong>로 나눈 값입니다.</p>
<p><span class="math display">\[d_z = \frac{|\bar{d}|}{s_d}\]</span></p>
<ul>
<li><strong>해석 기준:</strong> 독립표본 t-검정의 Cohen’s d와 동일한 기준을 적용합니다 (0.2: 작음, 0.5: 중간, 0.8: 큼).</li>
<li><strong>파이썬 계산:</strong></li>
</ul>
<div id="c54adf26" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Cohen's dz 계산</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>mean_diff <span class="op">=</span> df_paired[<span class="st">'Stress_Diff'</span>].mean()</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>std_diff <span class="op">=</span> df_paired[<span class="st">'Stress_Diff'</span>].std(ddof<span class="op">=</span><span class="dv">1</span>) <span class="co"># ddof=1은 표본 표준편차 사용</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>cohen_dz <span class="op">=</span> <span class="bu">abs</span>(mean_diff) <span class="op">/</span> std_diff</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Cohen's dz for Paired Samples (Stress Change): </span><span class="sc">{</span>cohen_dz<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="co"># 해석 (예시)</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> cohen_dz <span class="op">&lt;</span> <span class="fl">0.2</span>:</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>    effect_size_interpretation <span class="op">=</span> <span class="st">"매우 작음 (trivial)"</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a><span class="cf">elif</span> cohen_dz <span class="op">&lt;</span> <span class="fl">0.5</span>:</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>    effect_size_interpretation <span class="op">=</span> <span class="st">"작음 (small)"</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a><span class="cf">elif</span> cohen_dz <span class="op">&lt;</span> <span class="fl">0.8</span>:</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>    effect_size_interpretation <span class="op">=</span> <span class="st">"중간 (medium)"</span></span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>    effect_size_interpretation <span class="op">=</span> <span class="st">"큼 (large)"</span></span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"효과 크기 해석: </span><span class="sc">{</span>effect_size_interpretation<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Cohen's dz for Paired Samples (Stress Change): 0.677
효과 크기 해석: 중간 (medium)</code></pre>
</div>
</div>
</section>
<section id="결과-보고-1" class="level3" data-number="3.2.5">
<h3 data-number="3.2.5" class="anchored" data-anchor-id="결과-보고-1"><span class="header-section-number">3.2.5</span> 3.2.5 결과 보고</h3>
<p>대응표본 t-검정 결과를 보고할 때는 다음 정보들을 포함합니다.</p>
<ol type="1">
<li>비교 대상인 두 측정 시점 또는 조건.</li>
<li>측정된 종속변수.</li>
<li>각 시점/조건의 평균(M)과 표준편차(SD) (또는 차이 점수의 평균과 표준편차).</li>
<li>t-통계량 값과 자유도(<span class="math inline">\(df = n-1\)</span>).</li>
<li>p-값.</li>
<li>효과 크기 (Cohen’s <span class="math inline">\(d_z\)</span>).</li>
</ol>
<ul>
<li><strong>보고 예시 (위 예시 결과가 유의미했다고 가정):</strong> “스트레스 감소 프로그램의 효과를 검증하기 위해 대응표본 t-검정을 실시하였다. 분석 결과, 프로그램 참여 후 스트레스 점수(M = [사후평균], SD = [사후표준편차])는 참여 전(M = [사전평균], SD = [사전표준편차])에 비해 통계적으로 유의미하게 감소하였다 (t([df 값]) = [t-값], p = [p-값], Cohen’s <span class="math inline">\(d_z\)</span> = [d_z 값]). 이는 프로그램이 스트레스 감소에 [작은/중간/큰] 정도의 효과가 있음을 시사한다.”</li>
</ul>
</section>
<section id="요약-및-다음-단계-1" class="level3" data-number="3.2.6">
<h3 data-number="3.2.6" class="anchored" data-anchor-id="요약-및-다음-단계-1"><span class="header-section-number">3.2.6</span> 3.2.6 요약 및 다음 단계</h3>
<p>이번 절에서는 동일 집단 내 반복 측정값 또는 짝지어진 데이터의 평균 차이를 비교하는 대응표본 t-검정에 대해 학습했습니다. 핵심은 <strong>차이 점수</strong>를 계산하여 이에 대한 단일 표본 t-검정을 수행하는 것입니다. 가정(특히 차이 점수의 정규성), 파이썬 구현(<code>ttest_rel</code>), 결과 해석, 효과 크기(<span class="math inline">\(d_z\)</span>) 계산 방법을 익혔습니다.</p>
<p><strong>핵심 사항:</strong></p>
<ul>
<li>대응표본 t-검정은 <strong>관련된(related) 두 측정값</strong>의 평균 비교에 사용됩니다.</li>
<li>각 쌍 내의 <strong>차이 점수</strong>를 분석하며, 자유도는 <span class="math inline">\(df = n-1\)</span> (<span class="math inline">\(n\)</span>=쌍의 개수)입니다.</li>
<li><strong>차이 점수의 정규성</strong> 가정이 중요합니다.</li>
<li>개인 간 변동성을 통제하므로, 적용 가능한 경우 독립표본 t-검정보다 <strong>검정력(statistical power)</strong>이 더 높을 수 있습니다.</li>
</ul>
<p><strong>한계점:</strong> t-검정(독립/대응)은 모두 <strong>두 개의 평균</strong>만을 비교할 수 있습니다. 만약 비교하려는 집단이나 조건이 <strong>세 개 이상</strong>이라면 어떻게 해야 할까요? 다음 절(3.3)에서는 이러한 상황에 적용할 수 있는 <strong>분산분석(Analysis of Variance, ANOVA)</strong>에 대해 알아보겠습니다.</p>
<hr>
</section>
</section>
<section id="sec-one-way-anova" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="sec-one-way-anova"><span class="header-section-number">3.3</span> 3.3 일원분산분석 (ANOVA): 세 개 이상 집단의 평균 비교</h2>
<p>앞선 두 절에서는 두 집단 간의 평균을 비교하는 t-검정(독립표본, 대응표본)에 대해 학습했습니다. 하지만 사회과학 연구에서는 종종 <strong>세 개 이상의 집단</strong> 간의 평균을 비교해야 하는 경우가 발생합니다. 예를 들어, 서로 다른 세 가지 교육 방법(A, B, C)의 효과를 비교하거나, 네 개의 다른 지역(서울, 부산, 대구, 광주) 주민들의 평균 소득을 비교하는 상황 등을 생각해볼 수 있습니다.</p>
<p>이런 상황에서 각 집단 쌍마다 독립표본 t-검정을 반복적으로 수행하는 것은 적절하지 않습니다. 왜냐하면 검정을 반복할수록, 실제로는 집단 간 차이가 없는데도 우연히 유의미한 차이가 있는 것처럼 잘못된 결론을 내릴 확률(제1종 오류, Type I error)이 증가하기 때문입니다(이를 ‘다중 비교 문제’ 또는 ’familywise error rate 증가’라고 합니다).</p>
<p><strong>일원분산분석(One-Way Analysis of Variance, ANOVA)</strong>은 이러한 문제를 해결하고 <strong>세 개 이상의 독립적인 집단</strong>들 간에 특정 <strong>연속형 종속변수의 평균</strong>에 통계적으로 유의미한 차이가 있는지를 <strong>한 번의 분석</strong>으로 검증하는 강력한 통계 기법입니다. “일원(One-Way)”이라는 명칭은 집단을 나누는 독립변수(요인, factor)가 <strong>하나</strong>임을 의미합니다.</p>
<p>ANOVA의 주요 목적은 여러 집단들의 모집단 평균들이 <strong>모두 동일한지, 아니면 적어도 하나 이상의 집단 평균이 다른 집단들의 평균과 다른지</strong>를 판단하는 것입니다.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
📌 핵심 요약
</div>
</div>
<div class="callout-body-container callout-body">
<p>일원분산분석(One-Way ANOVA)은 세 개 이상 독립 집단 간 연속형 종속변수의 평균 차이를 검증합니다. 이 절에서는 ANOVA의 기본 원리(분산 분해: 총 변동 = 집단 간 변동 + 집단 내 변동), F-통계량 및 가설 검증, 주요 가정(독립성, 정규성, 등분산성), 파이썬 <code>statsmodels</code> 라이브러리를 이용한 구현 방법, ANOVA 테이블 해석, 효과 크기(에타 제곱, <span class="math inline">\(\eta^2\)</span>) 계산 및 해석, 그리고 사후 검정(post-hoc test)의 필요성까지 학습합니다.</p>
</div>
</div>
<section id="anova의-기본-원리-분산의-분해" class="level3" data-number="3.3.1">
<h3 data-number="3.3.1" class="anchored" data-anchor-id="anova의-기본-원리-분산의-분해"><span class="header-section-number">3.3.1</span> 3.3.1 ANOVA의 기본 원리: 분산의 분해</h3>
<p>ANOVA는 이름(Analysis of Variance, 분산분석)에서 알 수 있듯이, 종속변수의 <strong>총 변동(Total Variation)</strong>을 서로 다른 요인에 의한 변동으로 <strong>분해(partitioning)</strong>하여 집단 간 평균 차이를 검증합니다.</p>
<ul>
<li><p><strong>총 제곱합 (SST, Total Sum of Squares):</strong> 모든 관측치가 전체 데이터의 평균(grand mean, <span class="math inline">\(\bar{y}_{..}\)</span>)으로부터 얼마나 떨어져 있는지를 나타내는 총 변동량입니다. <span class="math display">\[SST = \sum_{i=1}^{k}\sum_{j=1}^{n_i}(y_{ij} - \bar{y}_{..})^2\]</span> (여기서 <span class="math inline">\(k\)</span>는 집단의 수, <span class="math inline">\(n_i\)</span>는 <span class="math inline">\(i\)</span>번째 집단의 표본 크기, <span class="math inline">\(y_{ij}\)</span>는 <span class="math inline">\(i\)</span>번째 집단의 <span class="math inline">\(j\)</span>번째 관측치, <span class="math inline">\(\bar{y}_{..}\)</span>는 전체 평균)</p></li>
<li><p><strong>집단 간 제곱합 (SSB, Sum of Squares Between groups):</strong> 각 <strong>집단의 평균(<span class="math inline">\(\bar{y}_{i.}\)</span>)들</strong>이 전체 평균(<span class="math inline">\(\bar{y}_{..}\)</span>)으로부터 얼마나 떨어져 있는지를 나타내는 변동량입니다. 이는 집단 간의 차이, 즉 독립변수(요인)의 효과를 반영합니다. (SSG, SSModel 등으로도 표기) <span class="math display">\[SSB = \sum_{i=1}^{k} n_i (\bar{y}_{i.} - \bar{y}_{..})^2\]</span></p></li>
<li><p><strong>집단 내 제곱합 (SSW, Sum of Squares Within groups):</strong> 각 집단 <strong>내의 관측치들</strong>이 해당 집단의 평균(<span class="math inline">\(\bar{y}_{i.}\)</span>)으로부터 얼마나 떨어져 있는지를 나타내는 변동량입니다. 이는 집단 구분으로 설명되지 않는, 각 집단 내의 무작위 변동 또는 오차(error)를 반영합니다. (SSE, SSResidual 등으로도 표기) <span class="math display">\[SSW = \sum_{i=1}^{k}\sum_{j=1}^{n_i}(y_{ij} - \bar{y}_{i.})^2\]</span></p></li>
<li><p><strong>분산 분해의 핵심 관계:</strong> 총 변동은 집단 간 변동과 집단 내 변동의 합으로 분해됩니다. <span class="math display">\[SST = SSB + SSW\]</span></p></li>
</ul>
<p>ANOVA는 이 관계를 이용하여, <strong>집단 간 변동(SSB)</strong>이 <strong>집단 내 변동(SSW)</strong>에 비해 상대적으로 얼마나 큰지를 평가합니다. 만약 집단 간 평균 차이가 크다면 SSB가 커질 것이고, 이것이 집단 내의 무작위 변동(SSW)에 비해 충분히 크다면 집단 간 평균 차이가 유의미하다고 판단합니다.</p>
</section>
<section id="f-통계량과-가설-검증" class="level3" data-number="3.3.2">
<h3 data-number="3.3.2" class="anchored" data-anchor-id="f-통계량과-가설-검증"><span class="header-section-number">3.3.2</span> 3.3.2 F-통계량과 가설 검증</h3>
<p>제곱합(SS)은 표본 크기에 영향을 받으므로, 변동의 크기를 객관적으로 비교하기 위해 각 제곱합을 해당 <strong>자유도(degrees of freedom, df)</strong>로 나누어 <strong>평균 제곱(Mean Square, MS)</strong>을 계산합니다.</p>
<ul>
<li><strong>집단 간 평균 제곱 (MSB, Mean Square Between):</strong> 집단 간 변동을 나타내는 분산 추정치입니다. <span class="math display">\[MSB = \frac{SSB}{df_B} \quad \text{where } df_B = k - 1\]</span> (<span class="math inline">\(k\)</span>는 집단의 수)</li>
<li><strong>집단 내 평균 제곱 (MSW, Mean Square Within):</strong> 집단 내 오차 변동을 나타내는 분산 추정치입니다. 이는 모든 집단의 분산을 통합한 합동 분산(pooled variance)과 유사한 개념입니다. <span class="math display">\[MSW = \frac{SSW}{df_W} \quad \text{where } df_W = N - k\]</span> (<span class="math inline">\(N\)</span>은 전체 관측치 수)</li>
</ul>
<p><strong>F-통계량(F-statistic)</strong>은 이 두 평균 제곱의 비율로 계산됩니다.</p>
<p><span class="math display">\[F = \frac{MSB}{MSW} = \frac{\text{집단 간 분산 추정치}}{\text{집단 내 분산 추정치}}\]</span></p>
<ul>
<li><strong>F-값의 의미:</strong> F-값은 집단 간 평균 차이에 의한 변동성(신호, signal)이 집단 내 무작위 변동성(노이즈, noise)에 비해 얼마나 큰지를 나타냅니다. F-값이 크다는 것은 집단 간 차이가 집단 내 차이에 비해 상대적으로 크다는 것을 의미합니다.</li>
</ul>
<p><strong>가설 설정:</strong></p>
<ul>
<li><strong>귀무가설 (<span class="math inline">\(H_0: \mu_1 = \mu_2 = ... = \mu_k\)</span>):</strong> 비교하는 모든 집단의 모집단 평균은 동일하다.</li>
<li><strong>대립가설 (<span class="math inline">\(H_1\)</span>: Not all <span class="math inline">\(\mu_i\)</span> are equal):</strong> 적어도 하나 이상의 집단 평균은 다른 집단들의 평균과 다르다. (주의: <span class="math inline">\(H_1\)</span>은 ’모든 평균이 다르다’는 의미가 아닙니다.)</li>
</ul>
<p><strong>F-분포와 의사 결정:</strong></p>
<ul>
<li>귀무가설(<span class="math inline">\(H_0\)</span>)이 참일 경우, F-통계량은 분자 자유도 <span class="math inline">\(df_B = k-1\)</span>와 분모 자유도 <span class="math inline">\(df_W = N-k\)</span>를 갖는 <strong>F-분포</strong>를 따릅니다. F-분포는 양수 값만 가지며 오른쪽으로 꼬리가 긴 형태를 띱니다.</li>
<li>계산된 F-통계량 값을 해당 F-분포(<span class="math inline">\(F(k-1, N-k)\)</span>) 상에서 평가하여 <strong>p-값</strong>을 구합니다. p-값은 <span class="math inline">\(H_0\)</span>이 참일 때 관찰된 F-값 또는 그보다 더 큰 F-값이 나올 확률입니다.</li>
<li><strong>의사 결정:</strong> 유의수준 <span class="math inline">\(\alpha\)</span>(보통 0.05)와 p-값을 비교합니다.
<ul>
<li><strong>p-값 &lt; <span class="math inline">\(\alpha\)</span> :</strong> 귀무가설(<span class="math inline">\(H_0\)</span>)을 기각합니다. 즉, 적어도 한 집단의 평균은 다른 집단과 통계적으로 유의미하게 다르다고 결론 내립니다.</li>
<li><strong>p-값 <span class="math inline">\(\ge\)</span> <span class="math inline">\(\alpha\)</span> :</strong> 귀무가설(<span class="math inline">\(H_0\)</span>)을 기각하지 못합니다. 즉, 집단 간 평균 차이가 통계적으로 유의미하다는 충분한 근거를 찾지 못했다고 결론 내립니다.</li>
</ul></li>
</ul>
</section>
<section id="일원분산분석anova의-가정" class="level3" data-number="3.3.3">
<h3 data-number="3.3.3" class="anchored" data-anchor-id="일원분산분석anova의-가정"><span class="header-section-number">3.3.3</span> 3.3.3 일원분산분석(ANOVA)의 가정</h3>
<p>ANOVA 결과의 타당성을 확보하기 위해 다음과 같은 가정들이 충족되는지 확인해야 합니다.</p>
<ol type="1">
<li><strong>독립성 (Independence of Observations):</strong> 각 집단 내의 관측치들은 서로 독립적이며, 서로 다른 집단 간의 관측치들도 독립적이어야 합니다. 이는 주로 연구 설계(예: 무작위 할당)와 관련됩니다.</li>
<li><strong>정규성 (Normality):</strong> 종속변수는 <strong>각 집단별로</strong> 정규분포를 따라야 합니다.
<ul>
<li><strong>확인 방법:</strong> 각 집단별 데이터 또는 분석 모형의 <strong>잔차(residuals)</strong>에 대해 정규성 검정(Shapiro-Wilk 등)을 수행하거나, 히스토그램, Q-Q 플롯 등으로 시각적으로 확인합니다.</li>
<li><strong>견고성:</strong> ANOVA는 정규성 가정 위반에 비교적 강건한 편이며, 특히 각 집단의 표본 크기가 크고 비슷할 경우 더욱 그렇습니다.</li>
</ul></li>
<li><strong>등분산성 (Homogeneity of Variances, Homoscedasticity):</strong> 모든 집단의 <strong>모집단 분산</strong>이 동일해야 합니다 (<span class="math inline">\(\sigma_1^2 = \sigma_2^2 = ... = \sigma_k^2\)</span>).
<ul>
<li><strong>확인 방법:</strong> Levene 검정 또는 Bartlett 검정을 수행합니다. Levene 검정이 정규성 가정에 덜 민감하여 더 널리 사용됩니다.</li>
<li><strong>중요성:</strong> 등분산성 가정이 심각하게 위반되면(특히 집단 크기가 다를 때) ANOVA 결과(F-값)의 신뢰도가 떨어질 수 있습니다. 이 경우 Welch’s ANOVA와 같은 대안적인 방법을 고려해야 할 수 있습니다 (고급 내용).</li>
</ul></li>
</ol>
</section>
<section id="파이썬-statsmodels를-이용한-일원분산분석" class="level3" data-number="3.3.4">
<h3 data-number="3.3.4" class="anchored" data-anchor-id="파이썬-statsmodels를-이용한-일원분산분석"><span class="header-section-number">3.3.4</span> 3.3.4 파이썬 <code>statsmodels</code>를 이용한 일원분산분석</h3>
<p>파이썬에서는 <code>statsmodels</code> 패키지를 사용하여 ANOVA를 편리하게 수행하고 결과를 해석할 수 있습니다. 특히 <code>statsmodels.formula.api</code>는 R과 유사한 공식(formula) 기반으로 모델을 정의할 수 있어 직관적입니다.</p>
<p>여기서는 2.5절의 <code>df_practice</code> 데이터를 이용하여 교육 수준(<code>Education</code>)이라는 <strong>하나의 요인(factor)</strong>이 주관적 웰빙(<code>Wellbeing</code>) 점수에 미치는 영향을 분석해보겠습니다. (<code>Education</code>은 4개의 수준/집단: High School, Bachelor, Master, PhD)</p>
<p><strong>1. 라이브러리 임포트 및 데이터 준비:</strong></p>
<div id="02f8a48b" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> scipy <span class="im">import</span> stats</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> statsmodels.api <span class="im">as</span> sm</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> statsmodels.formula.api <span class="im">as</span> smf</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> statsmodels.stats.anova <span class="im">import</span> anova_lm</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a><span class="co"># 데이터 로드 (3.1절과 동일하게 data_process.csv 사용 가정)</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a><span class="cf">try</span>:</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>    df_practice <span class="op">=</span> pd.read_csv(<span class="st">'data_process.csv'</span>, index_col<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Education 타입 재지정 (필요시)</span></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="st">'Education'</span> <span class="kw">in</span> df_practice.columns <span class="kw">and</span> (<span class="kw">not</span> pd.api.types.is_categorical_dtype(df_practice[<span class="st">'Education'</span>]) <span class="kw">or</span> <span class="kw">not</span> df_practice[<span class="st">'Education'</span>].cat.ordered):</span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a>         edu_order <span class="op">=</span> [<span class="st">'High School'</span>, <span class="st">'Bachelor'</span>, <span class="st">'Master'</span>, <span class="st">'PhD'</span>]</span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a>         df_practice[<span class="st">'Education'</span>] <span class="op">=</span> pd.Categorical(df_practice[<span class="st">'Education'</span>], categories<span class="op">=</span>edu_order, ordered<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"데이터 로드 및 준비 완료."</span>)</span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(df_practice[[<span class="st">'Education'</span>, <span class="st">'Wellbeing'</span>]].head())</span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a><span class="cf">except</span> <span class="pp">FileNotFoundError</span>:</span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"오류: 'data_process.csv' 파일을 찾을 수 없습니다."</span>)</span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 예제 진행을 위해 중단</span></span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">raise</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>데이터 로드 및 준비 완료.
     Education  Wellbeing
0  High School        4.1
1          PhD        0.4
2     Bachelor        8.5
3     Bachelor       10.4
4       Master        5.9</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Users\voidm\AppData\Local\Temp\ipykernel_34772\2485210584.py:14: DeprecationWarning:

is_categorical_dtype is deprecated and will be removed in a future version. Use isinstance(dtype, pd.CategoricalDtype) instead
</code></pre>
</div>
</div>
<p><strong>2. 가정 검토:</strong></p>
<ul>
<li><strong>정규성 검토 (잔차 기준):</strong> ANOVA 모델을 적합시킨 후 잔차의 정규성을 확인하는 것이 일반적입니다. (ANOVA 수행 후 진행)</li>
<li><strong>등분산성 검토 (Levene’s Test):</strong> 각 교육 수준 집단별 <code>Wellbeing</code> 점수의 분산이 동일한지 확인합니다. 귀무가설(<span class="math inline">\(H_0\)</span>)은 ’모든 집단의 분산은 같다’입니다.</li>
</ul>
<div id="09fa2ec1" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Levene의 등분산성 검정</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 각 교육 수준 그룹의 Wellbeing 데이터 추출</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    groups_wellbeing <span class="op">=</span> [df_practice[<span class="st">'Wellbeing'</span>][df_practice[<span class="st">'Education'</span>] <span class="op">==</span> level] <span class="cf">for</span> level <span class="kw">in</span> df_practice[<span class="st">'Education'</span>].cat.categories]</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    levene_stat, levene_p <span class="op">=</span> stats.levene(<span class="op">*</span>groups_wellbeing) <span class="co"># *는 리스트의 각 항목을 개별 인자로 전달</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">--- Levene's Test for Homogeneity of Variances (Wellbeing by Education) ---"</span>)</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Levene Statistic: </span><span class="sc">{</span>levene_stat<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"P-value: </span><span class="sc">{</span>levene_p<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> levene_p <span class="op">&lt;</span> <span class="fl">0.05</span>:</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"주의: 등분산성 가정이 위반되었을 수 있습니다 (p &lt; 0.05)."</span>)</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">"등분산성 가정을 만족합니다 (p &gt;= 0.05)."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
--- Levene's Test for Homogeneity of Variances (Wellbeing by Education) ---
Levene Statistic: 0.749
P-value: 0.525
등분산성 가정을 만족합니다 (p &gt;= 0.05).</code></pre>
</div>
</div>
<p><strong>3. ANOVA 수행 (<code>statsmodels</code> 사용):</strong></p>
<ul>
<li><strong>모델 정의:</strong> <code>종속변수 ~ C(독립변수_요인)</code> 형식의 공식을 사용합니다. <code>C()</code>는 해당 변수를 범주형(Categorical)으로 처리하도록 명시합니다.</li>
<li><strong>모델 적합:</strong> <code>ols</code> 함수(Ordinary Least Squares, 최소제곱법)를 사용하여 모델을 데이터에 적합시킵니다. ANOVA는 선형 모델의 특별한 경우로 볼 수 있습니다.</li>
<li><strong>ANOVA 테이블 생성:</strong> <code>anova_lm</code> 함수를 사용하여 적합된 모델로부터 ANOVA 테이블을 생성합니다. <code>typ=2</code> (Type II 제곱합)는 주 효과(main effect)를 평가하는 데 일반적으로 적합합니다.</li>
</ul>
<div id="cb9ce0ad" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ANOVA 모델 정의 및 적합</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>formula <span class="op">=</span> <span class="st">'Wellbeing ~ C(Education)'</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> smf.ols(formula, data<span class="op">=</span>df_practice).fit()</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="co"># ANOVA 테이블 생성</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>anova_table <span class="op">=</span> anova_lm(model, typ<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">--- One-Way ANOVA Results (Wellbeing by Education) ---"</span>)</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(anova_table)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
--- One-Way ANOVA Results (Wellbeing by Education) ---
                  sum_sq    df        F    PR(&gt;F)
C(Education)   11.377894   3.0  1.11272  0.347865
Residual      327.209606  96.0      NaN       NaN</code></pre>
</div>
</div>
<p><strong>4. ANOVA 테이블 해석:</strong></p>
<p>출력된 ANOVA 테이블의 주요 항목을 해석합니다.</p>
<ul>
<li><strong><code>C(Education)</code> 행:</strong> 집단 간 변동(Between-Group Variation)에 대한 정보입니다.
<ul>
<li><code>sum_sq</code>: SSB (집단 간 제곱합)</li>
<li><code>df</code>: <span class="math inline">\(df_B = k - 1\)</span> (여기서는 4개 그룹이므로 3)</li>
<li><code>mean_sq</code>: MSB (<span class="math inline">\(SSB / df_B\)</span>)</li>
<li><code>F</code>: F-통계량 (<span class="math inline">\(MSB / MSW\)</span>)</li>
<li><code>PR(&gt;F)</code>: p-값</li>
</ul></li>
<li><strong><code>Residual</code> 행:</strong> 집단 내 변동(Within-Group Variation)에 대한 정보입니다.
<ul>
<li><code>sum_sq</code>: SSW (집단 내 제곱합)</li>
<li><code>df</code>: <span class="math inline">\(df_W = N - k\)</span> (여기서는 100 - 4 = 96)</li>
<li><code>mean_sq</code>: MSW (<span class="math inline">\(SSW / df_W\)</span>)</li>
</ul></li>
<li><strong>의사 결정:</strong> <code>C(Education)</code> 행의 <code>PR(&gt;F)</code> (p-값)을 유의수준(<span class="math inline">\(\alpha=0.05\)</span>)과 비교합니다.
<ul>
<li>만약 p-값이 0.05보다 작으면 (예: 0.005), 귀무가설을 기각합니다. “교육 수준에 따라 주관적 웰빙 점수 평균에 통계적으로 유의미한 차이가 있다”고 결론 내립니다.</li>
<li>만약 p-값이 0.05보다 크거나 같으면 (예: 0.120), 귀무가설을 기각하지 못합니다. “교육 수준에 따른 주관적 웰빙 점수 평균 차이가 통계적으로 유의미하다는 증거를 찾지 못했다”고 결론 내립니다.</li>
</ul></li>
</ul>
<p><strong>5. 잔차 정규성 검토 (가정 검토 마무리):</strong> 모델 적합 후 잔차(<code>model.resid</code>)의 정규성을 확인합니다.</p>
<div id="b19bea64" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 잔차 추출</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>residuals <span class="op">=</span> model.resid</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="co"># 잔차 정규성 검정 (Shapiro-Wilk)</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>shapiro_resid <span class="op">=</span> stats.shapiro(residuals)</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">--- Normality Test of Residuals (Shapiro-Wilk) ---"</span>)</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Statistic: </span><span class="sc">{</span>shapiro_resid<span class="sc">.</span>statistic<span class="sc">:.3f}</span><span class="ss">, p-value: </span><span class="sc">{</span>shapiro_resid<span class="sc">.</span>pvalue<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a><span class="co"># 잔차 히스토그램 (시각적 확인)</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">7</span>, <span class="dv">5</span>))</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>sns.histplot(residuals, kde<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Histogram of Residuals'</span>)</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Residuals'</span>)</span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Frequency'</span>)</span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
--- Normality Test of Residuals (Shapiro-Wilk) ---
Statistic: 0.986, p-value: 0.391</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="03-group-difference-tests_files/figure-html/cell-15-output-2.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<ul>
<li><strong>해석:</strong> Shapiro-Wilk 검정 p-값이 0.05보다 크면 잔차의 정규성 가정을 만족한다고 볼 수 있습니다. 히스토그램이 종 모양에 가까운지도 확인합니다.</li>
</ul>
</section>
<section id="효과-크기-계산-및-해석-에타-제곱-eta2" class="level3" data-number="3.3.5">
<h3 data-number="3.3.5" class="anchored" data-anchor-id="효과-크기-계산-및-해석-에타-제곱-eta2"><span class="header-section-number">3.3.5</span> 3.3.5 효과 크기 계산 및 해석 (에타 제곱, <span class="math inline">\(\eta^2\)</span>)</h3>
<p>ANOVA의 F-검정이 유의미하다는 것은 집단 간 평균 차이가 존재한다는 것을 말해주지만, 그 차이가 <strong>실질적으로 얼마나 큰지</strong>, 즉 독립변수(요인)가 종속변수의 변동을 <strong>얼마나 설명하는지</strong>는 알려주지 않습니다. 이를 위해 <strong>효과 크기(Effect Size)</strong>를 계산하며, ANOVA에서는 <strong>에타 제곱(Eta-squared, <span class="math inline">\(\eta^2\)</span>)</strong>이 널리 사용됩니다.</p>
<ul>
<li><strong>에타 제곱 (<span class="math inline">\(\eta^2\)</span>) 정의:</strong> 종속변수의 총 변동(SST) 중에서 독립변수(집단 구분)에 의해 설명되는 변동(SSB)의 비율입니다. <span class="math display">\[\eta^2 = \frac{SSB}{SST} = \frac{SSB}{SSB + SSW}\]</span>
<ul>
<li><span class="math inline">\(\eta^2\)</span> 값은 0과 1 사이이며, 0에 가까울수록 독립변수가 종속변수를 거의 설명하지 못함을, 1에 가까울수록 많이 설명함을 의미합니다.</li>
</ul></li>
<li><strong>해석 기준 (Cohen의 제안, 사회과학 분야):</strong>
<ul>
<li><span class="math inline">\(\eta^2 \approx 0.01\)</span>: 작은 효과 크기</li>
<li><span class="math inline">\(\eta^2 \approx 0.06\)</span>: 중간 효과 크기</li>
<li><span class="math inline">\(\eta^2 \approx 0.14\)</span>: 큰 효과 크기</li>
</ul></li>
<li><strong>파이썬 계산:</strong> ANOVA 테이블의 <code>sum_sq</code> 값을 이용하여 직접 계산할 수 있습니다.</li>
</ul>
<div id="ec68f811" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ANOVA 테이블에서 SSB와 SSW 추출</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>ssb <span class="op">=</span> anova_table[<span class="st">'sum_sq'</span>][<span class="dv">0</span>] <span class="co"># 첫 번째 행 (C(Education))의 sum_sq</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>ssw <span class="op">=</span> anova_table[<span class="st">'sum_sq'</span>][<span class="dv">1</span>] <span class="co"># 두 번째 행 (Residual)의 sum_sq</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>sst <span class="op">=</span> ssb <span class="op">+</span> ssw <span class="co"># 총 제곱합</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span class="co"># 에타 제곱 계산</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>eta_squared <span class="op">=</span> ssb <span class="op">/</span> sst</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">--- Effect Size (Eta-squared) ---"</span>)</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Eta-squared (η²): </span><span class="sc">{</span>eta_squared<span class="sc">:.3f}</span><span class="ss">"</span>)</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a><span class="co"># 해석 (예시)</span></span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> eta_squared <span class="op">&lt;</span> <span class="fl">0.01</span>:</span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>    eta_interpretation <span class="op">=</span> <span class="st">"매우 작음 (trivial)"</span></span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a><span class="cf">elif</span> eta_squared <span class="op">&lt;</span> <span class="fl">0.06</span>:</span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>    eta_interpretation <span class="op">=</span> <span class="st">"작음 (small)"</span></span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a><span class="cf">elif</span> eta_squared <span class="op">&lt;</span> <span class="fl">0.14</span>:</span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a>    eta_interpretation <span class="op">=</span> <span class="st">"중간 (medium)"</span></span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a>    eta_interpretation <span class="op">=</span> <span class="st">"큼 (large)"</span></span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"효과 크기 해석: </span><span class="sc">{</span>eta_interpretation<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"해석: 교육 수준은 주관적 웰빙 점수 총 변동의 약 </span><span class="sc">{</span>eta_squared<span class="op">*</span><span class="dv">100</span><span class="sc">:.1f}</span><span class="ss">%를 설명합니다."</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
--- Effect Size (Eta-squared) ---
Eta-squared (η²): 0.034
효과 크기 해석: 작음 (small)
해석: 교육 수준은 주관적 웰빙 점수 총 변동의 약 3.4%를 설명합니다.</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>C:\Users\voidm\AppData\Local\Temp\ipykernel_34772\1585910648.py:2: FutureWarning:

Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`

C:\Users\voidm\AppData\Local\Temp\ipykernel_34772\1585910648.py:3: FutureWarning:

Series.__getitem__ treating keys as positions is deprecated. In a future version, integer keys will always be treated as labels (consistent with DataFrame behavior). To access a value by position, use `ser.iloc[pos]`
</code></pre>
</div>
</div>
</section>
<section id="사후-검정post-hoc-tests의-필요성" class="level3" data-number="3.3.6">
<h3 data-number="3.3.6" class="anchored" data-anchor-id="사후-검정post-hoc-tests의-필요성"><span class="header-section-number">3.3.6</span> 3.3.6 사후 검정(Post-Hoc Tests)의 필요성</h3>
<p>ANOVA 분석 결과 F-검정이 유의미하게 나왔다(즉, <span class="math inline">\(H_0\)</span>를 기각했다)면, 우리는 “적어도 한 집단의 평균은 다른 집단과 다르다”는 결론을 내릴 수 있습니다. 하지만 ANOVA 자체만으로는 <strong>구체적으로 어떤 집단들 사이에 차이가 있는지</strong>는 알려주지 않습니다. 예를 들어, 4개 교육 수준 집단 간 웰빙 평균에 유의미한 차이가 있다는 것을 알았더라도, 이것이 ‘PhD &gt; Master’, ‘Master &gt; Bachelor’, ‘Bachelor &gt; High School’ 중 어떤 차이 때문인지, 혹은 여러 차이가 복합적으로 작용한 결과인지 알 수 없습니다.</p>
<p>이처럼 전체 ANOVA 검정에서 유의미한 결과가 나왔을 때, <strong>구체적으로 어떤 집단 쌍(pair)들 간에 평균 차이가 유의미한지</strong>를 알아보기 위해 추가적으로 실시하는 분석을 <strong>사후 검정(Post-Hoc Tests)</strong> 또는 다중 비교(Multiple Comparisons)라고 합니다. 사후 검정은 여러 번의 쌍 비교를 수행하면서 발생할 수 있는 제1종 오류 증가 문제를 보정하는 다양한 방법(예: Tukey’s HSD, Bonferroni, Scheffé 등)을 포함합니다.</p>
<p><strong>사후 검정에 대한 자세한 내용과 파이썬 구현 방법은 다음 절(3.4)에서 다루겠습니다.</strong></p>
</section>
<section id="결과-보고-2" class="level3" data-number="3.3.7">
<h3 data-number="3.3.7" class="anchored" data-anchor-id="결과-보고-2"><span class="header-section-number">3.3.7</span> 3.3.7 결과 보고</h3>
<p>일원분산분석(One-Way ANOVA) 결과를 보고할 때는 다음 정보들을 포함합니다.</p>
<ol type="1">
<li>분석 방법(예: 일원분산분석).</li>
<li>독립변수(요인)와 종속변수.</li>
<li>F-통계량 값과 분자 및 분모 자유도 (<span class="math inline">\(F(df_B, df_W)\)</span>).</li>
<li>p-값.</li>
<li>효과 크기 (예: <span class="math inline">\(\eta^2\)</span>).</li>
<li>(선택적이지만 권장) 각 집단의 평균(M)과 표준편차(SD).</li>
<li>(ANOVA 결과가 유의미한 경우) 이어지는 사후 검정 방법에 대한 언급.</li>
</ol>
<ul>
<li><strong>보고 예시 (위 예시 결과가 유의미했다고 가정):</strong> “교육 수준(High School, Bachelor, Master, PhD)이 주관적 웰빙 점수에 미치는 영향을 알아보기 위해 일원분산분석(One-Way ANOVA)을 실시하였다. Levene 검정 결과 등분산성 가정이 충족되었다(p = [Levene p값]). ANOVA 분석 결과, 교육 수준에 따라 주관적 웰빙 점수에 통계적으로 유의미한 차이가 있는 것으로 나타났다 (<span class="math inline">\(F(3, 96) = [F값], p = [p값], \eta^2 = [Eta값]\)</span>). 이는 교육 수준이 주관적 웰빙 점수 총 변동의 약 [Eta값*100]%를 설명함을 의미하며, 그 효과 크기는 [작은/중간/큰] 수준이다. 유의미한 차이가 구체적으로 어떤 집단 간에 나타나는지 확인하기 위해 [사용할 사후 검정 방법]을 실시할 것이다.”</li>
</ul>
</section>
<section id="요약" class="level3" data-number="3.3.8">
<h3 data-number="3.3.8" class="anchored" data-anchor-id="요약"><span class="header-section-number">3.3.8</span> 3.3.8 요약</h3>
<p>이번 절에서는 세 개 이상의 독립적인 집단 간 평균 차이를 비교하는 일원분산분석(ANOVA)에 대해 학습했습니다. ANOVA는 종속변수의 총 변동을 집단 간 변동과 집단 내 변동으로 분해하고, 이들의 비율(F-통계량)을 이용하여 집단 간 평균 차이의 통계적 유의성을 검증합니다. <code>statsmodels</code> 라이브러리를 사용하여 파이썬으로 ANOVA를 수행하고 ANOVA 테이블을 해석하는 방법, 주요 가정(독립성, 정규성, 등분산성) 확인 방법, 효과 크기(<span class="math inline">\(\eta^2\)</span>) 계산 및 해석 방법을 익혔습니다.</p>
<p>ANOVA 결과가 유의미할 경우, 구체적으로 어떤 집단 간에 차이가 있는지를 밝히기 위한 <strong>사후 검정(Post-Hoc Tests)</strong>이 필요하며, 이는 다음 절에서 자세히 다룰 것입니다.</p>
<hr>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./02-data-handling-exploration.html" class="pagination-link" aria-label="제 2장  파이썬을 이용한 데이터 핸들링 및 탐색">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">제 2장 파이썬을 이용한 데이터 핸들링 및 탐색</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./04-categorical-data-analysis.html" class="pagination-link" aria-label="04-categorical-data-analysis.html">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">04-categorical-data-analysis.html</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>